<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mindmap</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="js/i18n.js"></script>
    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            /* ... standard body styles ... */
            font-family: "Geneva", "Verdana", sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
            touch-action: none;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            height: 90vh;
            width: 90%;
            max-width: 800px;
            position: relative;
            zoom: 1 !important;
            transform: scale(1) !important;
        }

        .window.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            border: none;
            box-shadow: none;
            z-index: 2000;
            transform-origin: top left !important;
        }

        .icon-btn {
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            padding: 0;
            flex-shrink: 0;
        }

        .icon-btn:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        .title-controls {
            position: absolute;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        /* Icon State Toggles */
        .icon-contract {
            display: none;
        }

        .window.fullscreen .icon-expand {
            display: none;
        }

        .window.fullscreen .icon-contract {
            display: inline;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
            zoom: var(--rekindle-scale, 1);
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* CONTROLS */
        .controls {
            position: absolute;
            right: 10px;
            z-index: 1;
            background: white;
            display: flex;
            gap: 10px;
        }

        .sys-btn {
            background: white;
            border: 2px solid black;
            padding: 4px 10px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-size: 0.8rem;
        }

        /* TOOLBAR */
        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            border-bottom: 2px solid black;
            background: #f5f5f5;
            flex-shrink: 0;
            zoom: var(--rekindle-scale, 1);
        }

        .toolbar-left,
        .toolbar-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* LIBRARY MODAL */
        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            padding: 10px;
            max-height: 60vh;
            overflow-y: auto;
            background: #eee;
            border: 2px solid black;
            min-height: 200px;
        }

        .mindmap-preview {
            border: 2px solid black;
            background: white;
            box-shadow: 2px 2px 0 black;
            display: flex;
            flex-direction: column;
            min-height: 150px;
            position: relative;
        }

        .mindmap-preview:active {
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        .mindmap-preview-canvas {
            flex-grow: 1;
            background-color: #fafafa;
            cursor: pointer;
            width: 100%;
            height: 120px;
        }

        .mindmap-preview-footer {
            padding: 5px 8px;
            border-top: 2px solid black;
            background: #f5f5f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }

        .mindmap-preview-title {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mindmap-preview-delete-btn {
            background: #ffcccc;
            border: 2px solid black;
            padding: 2px 6px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 1px 1px 0 black;
            font-size: 0.7rem;
        }

        .mindmap-preview-delete-btn:active {
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        .sys-btn.active {
            background: black;
            color: white;
            box-shadow: none;
        }

        .sys-btn:active {
            background: black;
            color: white;
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        /* WINDOW CONTENT / CANVAS CONTAINER */
        .window-content {
            flex-grow: 1;
            position: relative;
            background-color: #fafafa;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: grab;
        }

        #status-bar {
            border-top: 2px solid black;
            padding: 4px;
            font-size: 0.75rem;
            background: #eee;
            text-align: center;
            flex-shrink: 0;
            zoom: var(--rekindle-scale, 1);
        }

        /* ZOOM CONTROLS */
        .zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .zoom-btn {
            background: white;
            border: 2px solid black;
            width: 35px;
            height: 35px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:active {
            background: black;
            color: white;
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        /* MODAL STYLES */
        .modal-overlay {
            display: none;
            position: fixed;
            /* Use fixed to cover the whole viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-box {
            background: white;
            border: 2px solid black;
            box-shadow: 8px 8px 0 black;
            padding: 20px;
            width: 350px;
            max-width: 90%;
            text-align: center;
        }

        .modal-input {
            width: 100%;
            padding: 8px;
            margin: 15px 0;
            border: 2px solid black;
            box-sizing: border-box;
            font-family: inherit;
            font-size: 1rem;
        }
    </style>
    <script src="theme.js"></script>
</head>

<body>

    <div class="window">
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="window.location.href='index'">X</div>
            <span class="title-text" id="mindmap-title" data-i18n="mindmap.title">Mindmap</span>
            <div class="title-controls">
                <button class="icon-btn" onclick="toggleFullScreen()" title="Full Screen"
                    data-i18n-title="mindmap.btn.fullscreen">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                        stroke-linecap="square" stroke-linejoin="miter">
                        <path class="icon-expand" d="M15 3h6v6M14 10l6.1-6.1M9 21H3v-6M10 14l-6.1 6.1" />
                        <path class="icon-contract" d="M21 9H15V3M21 3l-6 6M3 15h6v6M3 21l6-6" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="toolbar">
            <div class="toolbar-left">
                <button class="sys-btn" onclick="showLibrary()" data-i18n="mindmap.btn.library">Library</button>
                <button class="sys-btn" onclick="newMindmap()" data-i18n="mindmap.btn.new">New</button>
            </div>
            <div class="toolbar-right">
                <button class="sys-btn" id="edit-btn" onclick="toggleEditMode()"
                    data-i18n="mindmap.btn.edit">Edit</button>
                <button class="sys-btn" onclick="resetView()" data-i18n="mindmap.btn.center">Center</button>
            </div>
        </div>

        <div class="window-content" id="canvas-container">
            <canvas id="mindmap-canvas"></canvas>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">-</button>
            </div>
        </div>
        <div id="status-bar" data-i18n="mindmap.status.initial">Double-click to add a node.</div>
    </div>

    <div id="node-modal" class="modal-overlay">
        <div class="modal-box">
            <h2 id="modal-title" style="margin-top:0; border-bottom: 2px solid black; padding-bottom:10px;"
                data-i18n="mindmap.modal.node_text">Node Text</h2>
            <input type="text" id="node-text-input" class="modal-input" placeholder="Enter text..."
                data-i18n-placeholder="mindmap.placeholder.node_text">
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="handleModalOk()" data-i18n="mindmap.btn.ok">OK</button>
                <button class="sys-btn" onclick="closeModal('node-modal')"
                    data-i18n="mindmap.btn.cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="library-modal" class="modal-overlay">
        <div class="modal-box" style="width: 80%; max-width: 700px;">
            <h2 style="margin-top:0; border-bottom: 2px solid black; padding-bottom:10px;"
                data-i18n="mindmap.header.library">My Mindmaps</h2>
            <div id="library-grid" class="library-grid">
                <!-- Mindmap previews will be injected here -->
            </div>
            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top: 20px;">
                <button class="sys-btn" onclick="closeModal('library-modal')"
                    data-i18n="mindmap.btn.close">Close</button>
            </div>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay">
        <div class="modal-box">
            <h2 style="margin-top:0;" data-i18n="mindmap.header.delete">Confirm Deletion</h2>
            <p><span data-i18n="mindmap.msg.delete_confirm_p1">Are you sure you want to delete the mindmap "</span><span
                    id="delete-map-name"></span><span data-i18n="mindmap.msg.delete_confirm_p2">"?</span></p>
            <p style="font-size: 0.8rem; color: #555;" data-i18n="mindmap.msg.delete_warning">This action cannot be
                undone.</p>
            <div style="display:flex; justify-content:center; gap:10px; margin-top: 20px;">
                <button class="sys-btn" onclick="executeDelete()" data-i18n="mindmap.btn.delete">Delete</button>
                <button class="sys-btn" onclick="closeModal('delete-modal')"
                    data-i18n="mindmap.btn.cancel">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Firebase Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // Configure for Safari/Mac compatibility (fixes CORS errors)
        if (db.settings) {
            try {
                db.settings({
                    experimentalForceLongPolling: true,
                    merge: true
                });
            } catch (e) { console.warn("Settings error:", e); }
        }
        // Note: Persistence disabled due to IndexedDB hangs on some browsers (Safari)

        // --- Canvas & State ---
        const canvas = document.getElementById('mindmap-canvas');
        const ctx = canvas.getContext('2d');
        const statusBar = document.getElementById('status-bar');

        // Polyfill for ctx.roundRect if not supported
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
            };
        }

        let nodes = [];
        let links = [];
        let currentUser = null;
        let saveTimer = null;

        let panOffset = { x: 0, y: 0 };
        let zoom = 1;
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };

        let isEditMode = false;
        let selectedNodeId = null;
        let draggedNodeId = null;
        let isDragging = false;

        let connectStartNodeId = null;
        let mindmapId = null;

        let activeNodeForModal = null;
        let newNodePosition = null;
        let mapIdToDelete = null;

        // --- Init ---
        window.onload = () => {
            if (window.rekindleApplyWallpaper) window.rekindleApplyWallpaper();
            if (window.rekindleApplyDefaultFullscreen) window.rekindleApplyDefaultFullscreen();

            const urlParams = new URLSearchParams(window.location.search);
            mindmapId = urlParams.get('id');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupEventListeners();

            auth.onAuthStateChanged(user => {
                currentUser = user;
                if (user) {
                    statusBar.innerText = window.t('mindmap.status.synced', "Synced: ${email}").replace('${email}', user.email);
                } else {
                    statusBar.innerText = window.t('mindmap.status.guest', "Guest Mode (Local)");
                }

                if (mindmapId) {
                    loadData();
                } else {
                    // No mindmap ID in URL, show the library by default
                    showLibrary();
                }
            });
        };

        // Helper to HTML-escape text
        function escapeHTML(text) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }

        // Helper to sanitize background image URLs from localStorage
        function sanitizeBackgroundImage(imageString) {
            if (!imageString) return '';
            if (imageString.startsWith('url("data:image/png;base64,')) {
                return imageString;
            }
            if (imageString.startsWith('url("') && imageString.endsWith('")')) {
                const url = imageString.substring(5, imageString.length - 2);
                if ((url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) && !url.includes('javascript:')) {
                    return imageString;
                }
            }
            return '';
        }


        // --- Data ---
        function updateTitle() {
            const titleElement = document.getElementById('mindmap-title');
            const defaultText = window.t('mindmap.node.default_text', 'Double tap to edit');
            const untitledText = window.t('mindmap.node.untitled', 'Untitled');
            const mindmapTitle = window.t('mindmap.title', 'Mindmap');

            if (nodes.length > 0 && nodes[0] && nodes[0].text) {
                let title = nodes[0].text;
                if (title === defaultText) {
                    titleElement.innerText = untitledText;
                } else {
                    titleElement.innerText = title;
                }
            } else {
                titleElement.innerText = mindmapTitle;
            }
        }

        function loadData() {
            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('mindmaps').doc(mindmapId).get().then(doc => {
                    if (doc.exists) {
                        const data = doc.data();
                        nodes = data.nodes || [];
                        links = data.links || [];
                        panOffset = data.panOffset || { x: 0, y: 0 };
                        zoom = data.zoom || 1;
                    } else {
                        // New map for this user, create default node
                        const container = document.getElementById('canvas-container');
                        nodes = [{ id: Date.now(), x: container.clientWidth / 2, y: container.clientHeight / 2, text: 'Double tap to edit', width: 120, height: 40 }];
                        links = [];
                        panOffset = { x: 0, y: 0 };
                        zoom = 1;
                    }
                    updateTitle();
                    render();
                });
            } else {
                loadLocalData();
                updateTitle();
                render();
            }
        }

        function loadLocalData() {
            const data = JSON.parse(localStorage.getItem('rekindle_mindmap_' + mindmapId));
            if (data) {
                nodes = data.nodes || [];
                links = data.links || [];
                panOffset = data.panOffset || { x: 0, y: 0 };
                zoom = data.zoom || 1;
            } else {
                // Default starting node
                const container = document.getElementById('canvas-container');
                nodes = [{ id: Date.now(), x: container.clientWidth / 2, y: container.clientHeight / 2, text: 'Double tap to edit', width: 120, height: 40 }];
                links = [];
                panOffset = { x: 0, y: 0 };
                zoom = 1;
            }
        }

        function saveData() {
            // Don't save if it's just the default, unedited node.
            const defaultText = window.t('mindmap.node.default_text', 'Double tap to edit');
            if (nodes.length === 1 && links.length === 0 && nodes[0].text === defaultText) {
                return;
            }

            const data = { nodes, links, panOffset, zoom };
            if (currentUser) {
                clearTimeout(saveTimer);
                saveTimer = setTimeout(() => {
                    db.collection('users').doc(currentUser.uid).collection('mindmaps').doc(mindmapId).set(data);
                }, 1000);
            } else {
                localStorage.setItem('rekindle_mindmap_' + mindmapId, JSON.stringify(data));
            }
        }

        // --- Canvas & Drawing ---
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            ctx.scale(dpr, dpr);
            render();
        }

        function toggleFullScreen() {
            document.querySelector('.window').classList.toggle('fullscreen');
            setTimeout(resizeCanvas, 50);
        }

        // --- Icon Drawing Helpers ---
        function drawIconContainer(x, y, radius) {
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }

        function drawXSymbol(x, y, size) {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size / 2, y - size / 2);
            ctx.lineTo(x + size / 2, y + size / 2);
            ctx.moveTo(x + size / 2, y - size / 2);
            ctx.lineTo(x - size / 2, y + size / 2);
            ctx.stroke();
        }

        function drawPlusSymbol(x, y, size) {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size / 2, y);
            ctx.lineTo(x + size / 2, y);
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x, y + size / 2);
            ctx.stroke();
        }

        function getWrappedLines(context, text, maxWidth) {
            const words = text.split(' ');
            let line = '';
            let lines = [];
            if (!text) return lines;

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line.trim());
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line.trim());
            return lines;
        }

        function drawNodeIcons(node) {
            const iconRadius = 8;
            const symbolSize = iconRadius; // Size of the + and X symbols

            // Delete Icon (Top Left)
            const delX = node.x - node.width / 2;
            const delY = node.y - node.height / 2;
            drawIconContainer(delX, delY, iconRadius);
            drawXSymbol(delX, delY, symbolSize);

            // Add Link Icon (Bottom Right)
            const addX = node.x + node.width / 2;
            const addY = node.y + node.height / 2;
            drawIconContainer(addX, addY, iconRadius);
            drawPlusSymbol(addX, addY, symbolSize);
        }

        function drawLinkIcons(link) {
            const fromNode = nodes.find(n => n.id === link.from), toNode = nodes.find(n => n.id === link.to);
            if (!fromNode || !toNode) return;
            const midX = (fromNode.x + toNode.x) / 2, midY = (fromNode.y + toNode.y) / 2, iconRadius = 8;
            drawIconContainer(midX, midY, iconRadius);
            drawXSymbol(midX, midY, iconRadius);
        }

        function render() {
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoom, zoom);

            // Draw links
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            links.forEach(link => { // Draw links first
                const fromNode = nodes.find(n => n.id === link.from);
                const toNode = nodes.find(n => n.id === link.to);
                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                }
            });

            // Draw link icons if in edit mode
            if (isEditMode) {
                links.forEach(drawLinkIcons);
            }


            // Draw nodes
            nodes.forEach(node => {
                const maxWidth = 200;
                const lineHeight = 18;
                const padding = 20;

                ctx.font = 'bold 14px Geneva, Verdana, sans-serif';
                const lines = getWrappedLines(ctx, node.text, maxWidth);
                const textBlockHeight = lines.length * lineHeight;

                let maxLineWidth = 0;
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    if (lineWidth > maxLineWidth) {
                        maxLineWidth = lineWidth;
                    }
                });
                node.width = maxLineWidth + padding;
                node.height = textBlockHeight + padding - (lineHeight / 2);

                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;

                if (node.id === selectedNodeId) {
                    ctx.fillStyle = 'black';
                }
                if (isEditMode && connectStartNodeId && node.id === connectStartNodeId) {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 3;
                }

                ctx.beginPath();
                ctx.roundRect(node.x - node.width / 2, node.y - node.height / 2, node.width, node.height, 8);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = (node.id === selectedNodeId) ? 'white' : 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const startTextY = node.y - (textBlockHeight / 2) + (lineHeight / 2);
                for (let i = 0; i < lines.length; i++) {
                    ctx.fillText(lines[i], node.x, startTextY + (i * lineHeight));
                }

                // Draw node icons if in edit mode
                if (isEditMode) {
                    drawNodeIcons(node);
                }
            });

            ctx.restore();
        }

        // --- Modal Functions ---
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            if (modalId === 'node-modal') {
                const input = document.getElementById('node-text-input');
                input.focus();
                input.select();
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            if (modalId === 'node-modal') {
                document.getElementById('node-text-input').value = '';
                activeNodeForModal = null;
                newNodePosition = null;
            } else if (modalId === 'delete-modal') {
                mapIdToDelete = null;
            }
        }

        function handleModalOk() {
            const newText = document.getElementById('node-text-input').value;

            if (!mindmapId && !newNodePosition) {
                // This can happen if the modal is open while a map is deleted in the background
                return;
            }
            if (activeNodeForModal) { // Editing
                if (newText !== null) {
                    activeNodeForModal.text = newText;
                    // If editing the first node, update the mindmap title
                    if (nodes.length > 0 && activeNodeForModal.id === nodes[0].id) {
                        updateTitle();
                    }
                }
            } else if (newNodePosition) { // Creating a new node
                if (newText) { // Don't create a new node if text is empty
                    const newNode = { id: Date.now(), x: newNodePosition.x, y: newNodePosition.y, text: newText };
                    nodes.push(newNode);

                    // --- AUTO-CONNECT LOGIC ---
                    if (nodes.length > 1) {
                        let nearestNode = null;
                        let minDistance = Infinity;

                        // Find the nearest node to the new one
                        nodes.forEach(node => {
                            if (node.id === newNode.id) return; // Don't compare to itself
                            const dist = Math.sqrt(Math.pow(node.x - newNode.x, 2) + Math.pow(node.y - newNode.y, 2));
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestNode = node;
                            }
                        });

                        if (nearestNode) addLink(newNode.id, nearestNode.id);
                    }
                }
            }

            closeModal('node-modal');
            render();
            saveData();
        }

        function newMindmap() {
            const newId = 'map-' + Date.now() + Math.random().toString(36).substring(2, 7);
            window.location.href = window.location.pathname + '?id=' + newId;
        }

        function showLibrary() {
            const libraryGrid = document.getElementById('library-grid');
            libraryGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${window.t('mindmap.status.loading', "Loading...")}</p>`;
            openModal('library-modal');

            const maps = [];

            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('mindmaps').get().then(querySnapshot => {
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        const defaultText = window.t('mindmap.node.default_text', 'Double tap to edit');
                        const untitledText = window.t('mindmap.node.untitled', 'Untitled');
                        let title = data.nodes && data.nodes.length > 0 && data.nodes[0].text ? data.nodes[0].text : untitledText;
                        if (title === defaultText) title = untitledText;
                        maps.push({ id: doc.id, title: title, data: data });
                    });
                    renderLibrary(maps);
                }).catch(error => {
                    libraryGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${window.t('mindmap.error.load', "Error loading mindmaps.")}</p>`;
                    console.error("Error getting documents: ", error);
                });
            } else {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('rekindle_mindmap_')) {
                        const mindmapId = key.replace('rekindle_mindmap_', '');
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            const defaultText = window.t('mindmap.node.default_text', 'Double tap to edit');
                            const untitledText = window.t('mindmap.node.untitled', 'Untitled');
                            let title = data.nodes && data.nodes.length > 0 && data.nodes[0].text ? data.nodes[0].text : untitledText;
                            if (title === defaultText) title = untitledText;
                            maps.push({ id: mindmapId, title: title, data: data });
                        } catch (e) {
                            console.error('Could not parse mindmap data from local storage for key:', key);
                        }
                    }
                }
                renderLibrary(maps);
            }
        }

        function renderLibrary(maps) {
            const libraryGrid = document.getElementById('library-grid');
            libraryGrid.innerHTML = ''; // Clear

            if (maps.length === 0) {
                const noMapsMsg = window.t('mindmap.msg.no_mindmaps', "No mindmaps found. Click \"New\" to create one!");
                libraryGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${noMapsMsg}</p>`;
                return;
            }

            maps.sort((a, b) => a.title.localeCompare(b.title));

            maps.forEach(map => {
                const previewContainer = document.createElement('div');
                previewContainer.className = 'mindmap-preview';

                const canvas = document.createElement('canvas');
                canvas.className = 'mindmap-preview-canvas';
                canvas.onclick = () => openMindmap(map.id);

                const footer = document.createElement('div');
                footer.className = 'mindmap-preview-footer';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'mindmap-preview-title';
                titleSpan.innerText = map.title;
                titleSpan.title = map.title; // Tooltip for long titles

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'mindmap-preview-delete-btn';
                deleteBtn.innerText = window.t('mindmap.btn.delete', 'Delete');
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent opening the map
                    confirmDeleteMindmap(map.id, map.title);
                };

                footer.appendChild(titleSpan);
                footer.appendChild(deleteBtn);

                previewContainer.appendChild(canvas);
                previewContainer.appendChild(footer);

                libraryGrid.appendChild(previewContainer);

                // Use a timeout to ensure the canvas is in the DOM before drawing
                setTimeout(() => drawMindmapPreview(canvas, map.data), 0);
            });
        }

        function drawMindmapPreview(canvas, mapData) {
            if (!canvas || !mapData || !mapData.nodes || mapData.nodes.length === 0) {
                return;
            }
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const nodes = mapData.nodes;
            const links = mapData.links || [];

            // 1. Calculate bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                const nodeWidth = node.width || 120;
                const nodeHeight = node.height || 40;
                minX = Math.min(minX, node.x - nodeWidth / 2);
                minY = Math.min(minY, node.y - nodeHeight / 2);
                maxX = Math.max(maxX, node.x + nodeWidth / 2);
                maxY = Math.max(maxY, node.y + nodeHeight / 2);
            });

            const boundsWidth = maxX - minX;
            const boundsHeight = maxY - minY;
            const boundsCenterX = minX + boundsWidth / 2;
            const boundsCenterY = minY + boundsHeight / 2;

            // 2. Calculate scale and offset
            const padding = 10;
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;

            let zoom = 1;
            if (boundsWidth > 0 && boundsHeight > 0) {
                const zoomX = (canvasWidth - padding * 2) / boundsWidth;
                const zoomY = (canvasHeight - padding * 2) / boundsHeight;
                zoom = Math.min(zoomX, zoomY);
            }

            const panOffsetX = (canvasWidth / 2) - (boundsCenterX * zoom);
            const panOffsetY = (canvasHeight / 2) - (boundsCenterY * zoom);

            // 3. Draw
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.save();
            ctx.translate(panOffsetX, panOffsetY);
            ctx.scale(zoom, zoom);

            // Draw links
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            links.forEach(link => {
                const fromNode = nodes.find(n => n.id === link.from);
                const toNode = nodes.find(n => n.id === link.to);
                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach((node, index) => {
                const nodeWidth = node.width || 120;
                const nodeHeight = node.height || 40;

                ctx.lineWidth = 2;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = (index === 0) ? 'black' : 'white';

                ctx.beginPath();
                ctx.roundRect(node.x - nodeWidth / 2, node.y - nodeHeight / 2, nodeWidth, nodeHeight, 8 / zoom);
                ctx.fill();
                ctx.stroke();
            });

            ctx.restore();
        }

        function confirmDeleteMindmap(id, title) {
            mapIdToDelete = id;
            const confirmMsg = window.t('mindmap.msg.delete_confirm', "Are you sure you want to delete the mindmap \"${name}\"?").replace('${name}', title);
            document.querySelector('#delete-modal p').innerText = confirmMsg;
            openModal('delete-modal');
        }

        function executeDelete() {
            if (!mapIdToDelete) return;

            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('mindmaps').doc(mapIdToDelete).delete().then(() => {
                    const successMsg = window.t('mindmap.msg.delete_success', "Document successfully deleted!");
                    console.log(successMsg);
                    refreshLibraryAfterDelete();
                }).catch(error => {
                    const errMsg = window.t('mindmap.error.delete', "Error removing document: ") + error;
                    console.error(errMsg);
                    closeModal('delete-modal');
                });
            } else {
                localStorage.removeItem('rekindle_mindmap_' + mapIdToDelete);
                refreshLibraryAfterDelete();
            }
        }

        function refreshLibraryAfterDelete() {
            // If the deleted map is the one currently open, redirect to the library view
            if (mindmapId === mapIdToDelete) {
                window.location.href = window.location.pathname;
            } else {
                closeModal('delete-modal');
                showLibrary(); // Refresh the library view
            }
        }

        function openMindmap(id) {
            window.location.href = window.location.pathname + '?id=' + id;
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('dblclick', onDblClick);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            document.getElementById('node-text-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleModalOk();
                if (e.key === 'Escape') closeModal('node-modal');
            });
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            const btn = document.getElementById('edit-btn');
            btn.classList.toggle('active', isEditMode);
            const doneText = window.t('mindmap.btn.done', 'Done');
            const editText = window.t('mindmap.btn.edit', 'Edit');
            btn.innerText = isEditMode ? doneText : editText;

            // Reset connection state when exiting edit mode
            if (!isEditMode) {
                connectStartNodeId = null;
                statusBar.innerText = window.t('mindmap.status.initial', 'Double-click to add a node.');
            } else {
                statusBar.innerText = window.t('mindmap.status.edit_instructions', 'Click icons to delete or connect.');
            }

            render();
        }

        function startConnection(nodeId) {
            if (connectStartNodeId === nodeId) { // Clicked the same plus again
                connectStartNodeId = null;
                statusBar.innerText = window.t ? window.t('mindmap.status.edit_instructions') : 'Click icons to delete or connect.';
            } else {
                connectStartNodeId = nodeId;
                statusBar.innerText = window.t('mindmap.status.connect_instruction', 'Click another node to connect to.');
            }
            render();
        }

        function onPointerDown(e) {
            const pos = getCanvasPoint(e.clientX, e.clientY);

            if (isEditMode) {
                const iconRadius = 8;

                // Check node icons first
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];

                    // Delete Icon (Top Left)
                    const delX = node.x - node.width / 2;
                    const delY = node.y - node.height / 2;
                    if (Math.hypot(pos.x - delX, pos.y - delY) < iconRadius) {
                        deleteNode(node.id);
                        return;
                    }

                    // Add Link Icon (Bottom Right)
                    const addX = node.x + node.width / 2;
                    const addY = node.y + node.height / 2;
                    if (Math.hypot(pos.x - addX, pos.y - addY) < iconRadius) {
                        startConnection(node.id);
                        return;
                    }
                }

                // Check link delete icons
                for (const link of links) {
                    const fromNode = nodes.find(n => n.id === link.from);
                    const toNode = nodes.find(n => n.id === link.to);
                    if (fromNode && toNode) {
                        const midX = (fromNode.x + toNode.x) / 2;
                        const midY = (fromNode.y + toNode.y) / 2;
                        if (Math.hypot(pos.x - midX, pos.y - midY) < iconRadius) {
                            deleteLink(link);
                            return;
                        }
                    }
                }

                // Handle connecting nodes
                if (connectStartNodeId) {
                    const clickedNode = getNodeAt(pos.x, pos.y);
                    if (clickedNode && clickedNode.id !== connectStartNodeId) {
                        addLink(connectStartNodeId, clickedNode.id);
                        connectStartNodeId = null;
                        statusBar.innerText = window.t('mindmap.status.edit_instructions', 'Click icons to delete or connect.');
                        render();
                    }
                }
                return; // Prevent panning/dragging in edit mode
            }

            // --- Default Mode ---
            const clickedNode = getNodeAt(pos.x, pos.y);
            if (clickedNode) {
                isDragging = true;
                draggedNodeId = clickedNode.id;
                selectedNodeId = clickedNode.id;
            } else {
                isPanning = true;
                canvas.style.cursor = 'grabbing';
                selectedNodeId = null;
            }
            lastPanPoint = { x: e.clientX, y: e.clientY };
            render();
        }

        function onPointerMove(e) {
            if (isDragging && draggedNodeId) {
                const pos = getCanvasPoint(e.clientX, e.clientY);
                const node = nodes.find(n => n.id === draggedNodeId);
                node.x = pos.x;
                node.y = pos.y;
                render();
            } else if (isPanning) {
                const dx = e.clientX - lastPanPoint.x;
                const dy = e.clientY - lastPanPoint.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPoint = { x: e.clientX, y: e.clientY };
                render();
            }
        }

        function onPointerUp() {
            if (isDragging) saveData();
            if (isPanning) saveData();
            isDragging = false;
            isPanning = false;
            draggedNodeId = null;
            canvas.style.cursor = 'grab';
        }

        function onDblClick(e) {
            if (isEditMode) return;

            const pos = getCanvasPoint(e.clientX, e.clientY);
            const clickedNode = getNodeAt(pos.x, pos.y);

            const modalTitle = document.getElementById('modal-title');
            const modalInput = document.getElementById('node-text-input');

            if (clickedNode) {
                activeNodeForModal = clickedNode;
                modalTitle.innerText = window.t('mindmap.modal.edit_node', "Edit Node");
                modalInput.value = clickedNode.text;
            } else {
                newNodePosition = pos;
                modalTitle.innerText = window.t('mindmap.modal.new_node', "New Node");
                modalInput.value = "";
                modalInput.placeholder = window.t('mindmap.placeholder.node_text', "Enter text...");
            }
            openModal('node-modal');
        }

        function onWheel(e) {
            e.preventDefault();
            const pos = getCanvasPoint(e.clientX, e.clientY, false); // Don't transform point for zoom origin
            const zoomFactor = 1.1;
            const wheel = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;

            panOffset.x = (panOffset.x - pos.x) * wheel + pos.x;
            panOffset.y = (panOffset.y - pos.y) * wheel + pos.y;
            zoom *= wheel;

            render();
            saveData();
        }

        // --- Helpers ---
        function getCanvasPoint(x, y, transform = true) {
            const rect = canvas.getBoundingClientRect();
            const point = {
                x: x - rect.left,
                y: y - rect.top
            };
            if (transform) {
                point.x = (point.x - panOffset.x) / zoom;
                point.y = (point.y - panOffset.y) / zoom;
            }
            return point;
        }

        function getNodeAt(x, y) {
            // Iterate backwards to select top-most node
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (x > node.x - node.width / 2 && x < node.x + node.width / 2 &&
                    y > node.y - node.height / 2 && y < node.y + node.height / 2) {
                    return node;
                }
            }
            return null;
        }

        function deleteNode(nodeId) {
            if (!nodeId) return;
            nodes = nodes.filter(n => n.id !== nodeId);
            links = links.filter(l => l.from !== nodeId && l.to !== nodeId);
            if (selectedNodeId === nodeId) selectedNodeId = null;
            if (connectStartNodeId === nodeId) {
                connectStartNodeId = null;
                statusBar.innerText = window.t('mindmap.status.edit_instructions', 'Click icons to delete or connect.');
            }
            render();
            saveData();
        }

        function deleteLink(linkToDelete) {
            links = links.filter(l => !(l.from === linkToDelete.from && l.to === linkToDelete.to));
            render();
            saveData();
        }

        function addLink(fromId, toId) {
            const exists = links.some(l => (l.from === fromId && l.to === toId) || (l.from === toId && l.to === fromId));
            if (!exists) {
                links.push({ from: fromId, to: toId });
                saveData();
            }
        }

        function resetView() {
            if (nodes.length === 0) {
                panOffset = { x: 0, y: 0 };
                zoom = 1;
                render();
                saveData();
                return;
            }

            // Ensure node sizes are up-to-date for accurate bounding box
            const maxWidth = 200;
            const lineHeight = 18;
            const padding = 35;
            ctx.font = 'bold 14px Geneva, Verdana, sans-serif';
            nodes.forEach(node => {
                const lines = getWrappedLines(ctx, node.text, maxWidth);
                const textBlockHeight = lines.length * lineHeight;

                let maxLineWidth = 0;
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
                });

                node.width = maxLineWidth + padding;
                node.height = textBlockHeight + padding - (lineHeight / 2);
            });

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x - node.width / 2);
                minY = Math.min(minY, node.y - node.height / 2);
                maxX = Math.max(maxX, node.x + node.width / 2);
                maxY = Math.max(maxY, node.y + node.height / 2);
            });

            const boundsWidth = maxX - minX;
            const boundsHeight = maxY - minY;
            const boundsCenterX = minX + boundsWidth / 2;
            const boundsCenterY = minY + boundsHeight / 2;

            const container = document.getElementById('canvas-container');
            const canvasWidth = container.clientWidth;
            const canvasHeight = container.clientHeight;

            const zoomX = boundsWidth > 0 ? (canvasWidth - padding * 2) / boundsWidth : Infinity;
            const zoomY = boundsHeight > 0 ? (canvasHeight - padding * 2) / boundsHeight : Infinity;

            zoom = Math.min(zoomX, zoomY, 1);
            if (!isFinite(zoom)) zoom = 1;

            panOffset.x = (canvasWidth / 2) - (boundsCenterX * zoom);
            panOffset.y = (canvasHeight / 2) - (boundsCenterY * zoom);

            render();
            saveData();
        }

        function zoomIn() {
            applyZoom('in');
        }

        function zoomOut() {
            applyZoom('out');
        }

        function applyZoom(direction) {
            const container = document.getElementById('canvas-container');
            const pos = { x: container.clientWidth / 2, y: container.clientHeight / 2 };
            const zoomFactor = 1.2;
            const wheel = direction === 'in' ? zoomFactor : 1 / zoomFactor;

            panOffset.x = (panOffset.x - pos.x) * wheel + pos.x;
            panOffset.y = (panOffset.y - pos.y) * wheel + pos.y;
            zoom *= wheel;

            render();
            saveData();
        }


        // Wallpaper applied via theme.js window.rekindleApplyWallpaper()
    </script>
    <script src="https://cdn.counter.dev/script.js" data-id="4e551911-0e5d-4c48-91a6-b828c3301675"
        data-utcoffset="11"></script>
</body>

</html>