<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Flipbook</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            image-rendering: pixelated;
            font-family: "Geneva", "Verdana", sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
            touch-action: none;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            position: relative;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        /* CLOSE BUTTON */
        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* SCREENS */
        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .screen.active {
            display: flex;
        }

        /* GALLERY SCREEN */
        #screen-gallery {
            padding: 0;
            background: #eee;
        }

        .gallery-header {
            padding: 10px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            flex-shrink: 0;
        }

        .gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 20px;
            overflow-y: auto;
            align-content: start;
        }

        .gallery-item {
            background: white;
            border: 2px solid black;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            box-shadow: 4px 4px 0 #ccc;
            aspect-ratio: 1 / 1.2;
            justify-content: space-between;
            position: relative;
        }

        .gallery-item:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #ccc;
            background: black;
            color: white;
        }

        .gallery-preview {
            width: 100%;
            aspect-ratio: 1/1;
            border: 1px solid #ddd;
            image-rendering: pixelated;
            background: white;
            pointer-events: none;
            flex-shrink: 0;
            object-fit: contain;
        }

        .gallery-item.new-btn {
            justify-content: center;
            border-style: dashed;
            background: #fafafa;
        }

        .gallery-item.new-btn span {
            font-size: 3rem;
            font-weight: bold;
            color: #ccc;
        }

        .item-info {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            font-weight: bold;
        }

        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: white;
            border: 2px solid black;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
        }

        .delete-btn:hover {
            background: black;
            color: white;
        }

        /* EDITOR AREA */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            flex-grow: 1;
            background: white;
        }

        #canvas-container {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
            flex-grow: 1;
            min-height: 200px;
        }

        canvas {
            display: block;
            background: white;
            border: 2px solid black;
            width: 100%;
            /* Controlled by container */
            aspect-ratio: 1/1;
            image-rendering: pixelated;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }

        /* CONTROLS */
        .controls {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 5px;
            padding-bottom: 5px;
        }

        .transport {
            display: flex;
            align-items: center;
            background: #eee;
            border: 2px solid black;
            padding: 2px;
            gap: 2px;
        }

        .transport-btn {
            min-width: 30px;
            padding: 4px;
            font-size: 1rem;
        }

        /* TOOLBAR */
        .toolbar-group {
            display: flex;
            gap: 2px;
            background: #eee;
            border: 2px solid black;
            padding: 2px;
        }

        button.sys-btn {
            background: white;
            border: 2px solid black;
            padding: 8px 15px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        button.sys-btn:active,
        button.sys-btn.active {
            background: black;
            color: white;
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        /* NEW CONTROLS LAYOUT */
        .controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
            flex-wrap: nowrap;
            margin-top: 5px;
        }

        .control-group {
            display: flex;
            gap: -1px;
            /* Attached buttons look */
        }

        /* Group buttons together visually */
        .control-group .sys-btn {
            border-radius: 0;
            margin: 0;
            border-right: none;
            width: 40px;
            height: 32px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: white;
            box-shadow: 2px 2px 0 black;
        }

        .control-group .sys-btn:active,
        .control-group .sys-btn.active {
            background: black;
            color: white;
            box-shadow: inset 1px 1px 0 rgba(0, 0, 0, 0.5);
            /* or just remove shadow */
            transform: translate(1px, 1px);
        }

        .control-group .sys-btn.caution:hover {
            background: red;
            color: white;
        }

        /* REFINED CONTROLS LAYOUT */
        .controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 10px;
            width: 100%;
            background: #d6d6d6;
            /* Grey background */
            border-top: 1px solid black;
            box-sizing: border-box;
            flex-wrap: nowrap;
        }

        .control-group {
            display: flex;
            border: 1px solid black;
            background: black;
            /* Dividers */
            gap: 1px;
            padding: 0;
        }

        .control-group .sys-btn {
            border-radius: 0;
            margin: 0;
            border: none;
            width: auto;
            min-width: 44px;
            padding: 0 10px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            box-shadow: none;
            cursor: pointer;
            gap: 5px;
        }

        .btn-label {
            font-size: 0.9rem;
            font-weight: bold;
            display: inline;
        }

        .control-group .sys-btn:active,
        .control-group .sys-btn.active {
            background: black;
            color: white;
            transform: none;
        }

        .control-group .sys-btn.caution:hover {
            background: red;
            color: white;
        }

        .control-group .sys-btn svg {
            width: 22px;
            height: 22px;
        }

        /* MENU BAR */
        .menu-bar {
            display: flex;
            width: 100%;
            border-bottom: 2px solid black;
            background: white;
            padding: 2px 5px;
            gap: 15px;
            box-sizing: border-box;
            flex-shrink: 0;
            align-items: center;
        }

        .menu-btn {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 2px 6px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            text-transform: capitalize;
            font-weight: normal;
        }

        .menu-btn:hover:not(:disabled),
        .menu-btn:active:not(:disabled) {
            background: black;
            color: white;
            transform: none;
            box-shadow: none;
        }

        .menu-btn:disabled {
            color: #999;
            cursor: default;
        }

        /* MODALS */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(229, 229, 229, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-box {
            background: white;
            border: 2px solid black;
            box-shadow: none;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            text-align: center;
        }

        #frame-strip-visual {
            font-family: monospace;
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
    </style>
    <script src="theme.js"></script>
    <script src="pro-gate.js"></script>
    <script src="js/i18n.js"></script>
</head>

<body>

    <!-- MODALS -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-box">
            <div id="modal-message" style="margin-bottom:20px; font-weight:bold;"></div>
            <div id="modal-btns" style="display:flex; justify-content:center; gap:10px;"></div>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay">
        <div class="modal-box">
            <h3 data-i18n="flipbook.modal.delete.title">Delete Animation?</h3>
            <p style="margin-bottom:20px;" data-i18n="flipbook.modal.delete.desc">Are you sure you want to delete this
                animation?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="confirm-delete-btn" data-i18n="reddit.btn.remove">Delete</button>
                <button class="sys-btn" onclick="closeModal('delete-modal')"
                    data-i18n="reddit.btn.cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rename-modal" class="modal-overlay">
        <div class="modal-box">
            <h3 data-i18n="flipbook.modal.rename.title">Rename</h3>
            <input type="text" id="rename-input" maxlength="20"
                style="width:80%; padding:5px; margin-bottom:20px; font-family:inherit; font-weight:bold; text-align:center; border:2px solid black;">
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="confirm-rename-btn" data-i18n="flipbook.modal.rename.title">Rename</button>
                <button class="sys-btn" onclick="closeModal('rename-modal')"
                    data-i18n="reddit.btn.cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- POST CONFIRM MODAL -->
    <div id="post-confirm-modal" class="modal-overlay">
        <div class="modal-box">
            <h3 data-i18n="flipbook.modal.post.title">Post to KindleChat?</h3>
            <p style="margin-bottom:20px;" data-i18n="flipbook.modal.post.desc">Post this animation to General Chat?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="confirmPost()" data-i18n="msg.yes">Yes</button>
                <button class="sys-btn" onclick="closeModal('post-confirm-modal')" data-i18n="msg.no">No</button>
            </div>
        </div>
    </div>

    <div class="window">
        <!-- TITLE BAR -->
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="handleCloseButton()">X</div>
            <div id="editor-back-btn" class="close-box" style="left:38px; width:auto; padding:0 5px; display:none;"
                onclick="showGallery()" data-i18n="rss.btn.back">Back</div>
            <span class="title-text" data-i18n="flipbook.title">Flipbook</span>
            <!-- Contextual Back Button -->
            <div id="back-to-chat-btn" class="close-box"
                style="left:auto; right:10px; width:auto; padding:0 8px; font-weight:normal; display:none;"
                onclick="window.location.href='kindlechat'" data-i18n="kindlechat.btn.back">
                Back to Chat
            </div>
        </div>

        <!-- GALLERY SCREEN -->
        <div id="screen-gallery" class="screen active">
            <div class="gallery-header">
                <span style="font-weight:bold; margin-left:10px;" data-i18n="flipbook.gallery.title">My
                    Animations</span>
            </div>
            <div id="gallery-grid" class="gallery-grid">
                <!-- Injected via JS -->
                <div class="gallery-item new-btn" onclick="createNew()">
                    <span>+</span>
                    <div class="item-info" data-i18n="flipbook.gallery.new">New</div>
                </div>
            </div>
        </div>

        <!-- EDITOR SCREEN -->
        <div id="screen-editor" class="screen">
            <!-- Menu Bar -->
            <div class="menu-bar">
                <button class="menu-btn" onclick="openModal('post-confirm-modal')" data-i18n="flipbook.menu.post">Post
                    to KindleChat</button>
                <button class="menu-btn" onclick="downloadGIF()" disabled
                    data-i18n="flipbook.menu.download">Download</button>
                <button class="menu-btn" onclick="changeSpeed()" id="fps-btn">6 FPS</button>
            </div>

            <div class="game-content">
                <div id="canvas-container">
                    <canvas id="drawing-board" width="256" height="256"></canvas>
                </div>

                <div id="frame-strip-visual">Frame 1 / 1</div>

                <div class="controls-container">
                    <!-- Tools Group -->
                    <div class="control-group">
                        <button id="tool-pen" class="sys-btn icon-btn active" onclick="setTool('pen')"
                            data-i18n-title="flipbook.tool.pen" title="Pen">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M18 2l4 4-10 10H8v-4L18 2z"></path>
                            </svg>
                            <span class="btn-label" data-i18n="flipbook.tool.pen">Pen</span>
                        </button>
                        <button id="tool-eraser" class="sys-btn icon-btn" onclick="setTool('eraser')"
                            data-i18n-title="flipbook.tool.eraser" title="Eraser">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"></path>
                            </svg>
                            <span class="btn-label" data-i18n="flipbook.tool.eraser">Eraser</span>
                        </button>
                        <button class="sys-btn icon-btn" onclick="clearFrame()" data-i18n-title="flipbook.tool.clear"
                            title="Clear Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M18 6L6 18M6 6l12 12"></path>
                            </svg>
                            <span class="btn-label" data-i18n="flipbook.tool.clear">Clear</span>
                        </button>
                    </div>

                    <!-- Transport Group -->
                    <div class="control-group">
                        <button class="sys-btn icon-btn" onclick="prevFrame()" data-i18n-title="flipbook.transport.prev"
                            title="Previous Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M15 18l-6-6 6-6"></path>
                            </svg>
                        </button>
                        <button class="sys-btn icon-btn" id="play-btn" onclick="togglePlay()"
                            data-i18n-title="flipbook.transport.play" title="Play/Stop">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                <path d="M8 5v14l11-7z"></path>
                            </svg>
                        </button>
                        <button class="sys-btn icon-btn" onclick="nextFrame()" data-i18n-title="flipbook.transport.next"
                            title="Next Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Management Group -->
                    <div class="control-group">
                        <button class="sys-btn icon-btn" onclick="addFrame()" data-i18n-title="flipbook.mgmt.new"
                            title="New Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M12 5v14M5 12h14"></path>
                            </svg>
                        </button>
                        <button class="sys-btn icon-btn caution" onclick="deleteFrame()"
                            data-i18n-title="flipbook.mgmt.delete" title="Delete Frame">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path
                                    d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="paywall-overlay"
            style="display:none; position:absolute; top:35px; left:0; width:100%; height:calc(100% - 35px); background:rgba(255,255,255,0.98); z-index:500; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:20px; box-sizing:border-box;">
            <h2 style="margin-top:0;" data-i18n="paywall.title">ReKindle+</h2>
            <p data-i18n="paywall.desc">Support ReKindle development and get<br>access to exclusive apps.</p>
            <button class="sys-btn" onclick="window.location.href='pay.html'" data-i18n="btn.subscribe">Subscribe /
                Login</button>
            <p style="font-size:0.8rem; margin-top:20px; color:#666;" id="paywall-status" data-i18n="status.checking">
                Checking subscription...</p>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CANVAS_SIZE = 256;

        // --- STATE ---
        let currentAnimationId = null;
        let frames = []; // Array of ImageData
        let currentFrameIndex = 0;
        let isPlaying = false;
        let fps = 6;
        let playTimer = null;
        let onionSkin = true;

        let currentTool = 'pen';
        let isDrawing = false;
        let autoSaveTimer = null;

        let manifest = [];
        let db, auth, rtdb, currentUser = null;

        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77"
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('drawing-board');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const container = document.getElementById('canvas-container');

        // --- BUFFER (Off-screen) ---
        const bufferCanvas = document.createElement('canvas');
        bufferCanvas.width = CANVAS_SIZE;
        bufferCanvas.height = CANVAS_SIZE;
        const bufferCtx = bufferCanvas.getContext('2d', { willReadFrequently: true });

        // --- INIT ---
        window.onload = () => {
            if (window.rekindleApplyWallpaper) window.rekindleApplyWallpaper();

            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            rtdb = firebase.database();

            if (db.settings) {
                try { db.settings({ experimentalForceLongPolling: true, merge: true }); } catch (e) { }
            }

            auth.onAuthStateChanged(user => {
                currentUser = user;
                checkSubscription(user);
                initApp();
            });

            // Canvas Events
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', draw);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointerout', stopDrawing);

            // Prevent context menu
            canvas.oncontextmenu = (e) => e.preventDefault();

            // Check for source param
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('source') === 'kindlechat') {
                const backBtn = document.getElementById('back-to-chat-btn');
                if (backBtn) backBtn.style.display = 'flex';
                // Trigger auto-new
                if (typeof createNew === 'function') createNew();
            }

            window.addEventListener('resize', () => {
                if (document.getElementById('screen-editor').classList.contains('active')) setupCanvas();
            });
        };

        async function initApp() {
            await loadManifest();
            migrateLegacyData(); // Just in case
            renderGallery();
        }

        // --- MANIFEST LOGIC ---
        async function loadManifest() {
            const key = 'flipnote_manifest';
            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('settings').doc('flipnote_manifest').get();
                    if (doc.exists) {
                        manifest = doc.data().items || [];
                        localStorage.setItem(key, JSON.stringify(manifest));
                        return;
                    }
                } catch (e) { console.error("Cloud manifest load failed", e); }
            }
            const local = localStorage.getItem(key);
            if (local) {
                try { manifest = JSON.parse(local); } catch (e) { manifest = []; }
            } else {
                manifest = [];
            }
        }

        async function saveManifest() {
            const key = 'flipnote_manifest';
            localStorage.setItem(key, JSON.stringify(manifest));
            if (currentUser) {
                try {
                    await db.collection('users').doc(currentUser.uid).collection('settings').doc('flipnote_manifest').set({ items: manifest });
                } catch (e) { console.error("Cloud manifest save failed", e); }
            }
        }

        // --- GALLERY ---
        function renderGallery() {
            const gridEl = document.getElementById('gallery-grid');
            const newBtn = gridEl.firstElementChild;
            gridEl.innerHTML = '';
            gridEl.appendChild(newBtn);

            const sorted = [...manifest].sort((a, b) => b.modified - a.modified);

            sorted.forEach(item => {
                const el = document.createElement('div');
                el.className = 'gallery-item';
                el.onclick = (e) => {
                    if (!e.target.closest('.action-btn')) openAnimation(item.id);
                };

                let thumbHtml = '';
                if (item.thumbnail) {
                    thumbHtml = `<img src="${item.thumbnail}" class="gallery-preview">`;
                } else {
                    thumbHtml = `<div class="gallery-preview" style="background:#f0f0f0;"></div>`;
                }

                const title = item.title || "Untitled";
                const dateStr = new Date(item.modified).toLocaleDateString();
                const framesCount = item.frameCount || '?';

                el.innerHTML = `
                    <div class="delete-btn action-btn" onclick="deleteAnimation('${item.id}')">X</div>
                    ${thumbHtml}
                    <div class="item-info">
                        <div onclick="event.stopPropagation(); promptRename('${item.id}')" style="font-size:0.9rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:100px; cursor:pointer; text-decoration:underline;">${title}</div>
                        <span style="font-weight:normal; color:#666; font-size:0.7rem;">${framesCount} frames</span>
                    </div>
                `;
                gridEl.appendChild(el);
            });
        }

        function migrateLegacyData() {
            // Not needed since old flipnote had no persistence
        }

        // --- DRAWING / EDITOR LOGIC ---
        function createNew() {
            if (!isPro) {
                document.getElementById('paywall-overlay').style.display = 'flex';
                document.getElementById('paywall-status').innerText = "Pro subscription required to create animations.";
                return;
            }

            currentAnimationId = null;
            frames = [];
            currentFrameIndex = 0;
            fps = 6;

            // Initial Frame
            addFrame(true);

            showEditor();
            setupCanvas();
            loadCurrentFrameToBuffer();
        }

        function addFrame(isFirst = false) {
            if (isPlaying) stopPlaying();
            const newData = new ImageData(CANVAS_SIZE, CANVAS_SIZE);
            // Fill clear (transparent) or white?
            // Since it's flipnote, transparent background is better for layers but default canvas is white.
            // We want white background effectively.
            // But ImageData is transparent by default (0,0,0,0).
            // Let's rely on renderCanvas to draw white bg.

            if (isFirst) {
                frames.push(newData);
            } else {
                // Insert after current
                if (frames.length > 0) saveCurrentFrame();
                // Copy previous? Or Blank? Let's do Blank.
                frames.splice(currentFrameIndex + 1, 0, newData);
                currentFrameIndex++;
            }
            loadCurrentFrameToBuffer();
            renderCanvas();
            updateUI();
            triggerAutoSave();
        }

        async function openAnimation(id) {
            if (!isPro) {
                document.getElementById('paywall-overlay').style.display = 'flex';
                document.getElementById('paywall-status').innerText = "Pro subscription required to open animations.";
                return;
            }
            const item = manifest.find(m => m.id === id);
            if (!item) return;
            currentAnimationId = id;

            // Load frames
            let data = null;
            const key = `flipnote_anim_${id}`;

            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('flipnote_animations').doc(id).get();
                    if (doc.exists) data = doc.data();
                } catch (e) { }
            }
            if (!data) {
                const local = localStorage.getItem(key);
                if (local) data = JSON.parse(local);
            }

            if (data && data.frames && data.frames.length > 0) {
                // Convert Base64 strings back to ImageData
                frames = [];
                for (let src of data.frames) {
                    const img = new Image();
                    img.src = src;
                    await img.decode();
                    const temp = document.createElement('canvas');
                    temp.width = CANVAS_SIZE;
                    temp.height = CANVAS_SIZE;
                    temp.getContext('2d').drawImage(img, 0, 0);
                    frames.push(temp.getContext('2d').getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE));
                }
                fps = data.fps || 6;
            } else {
                createNew(); // Fallback
                return;
            }

            currentFrameIndex = 0;
            showEditor();
            setupCanvas();
            loadCurrentFrameToBuffer();
            renderCanvas();
            updateUI();
        }

        // --- SAVING ---
        let isSaving = false;
        async function performSave() {
            if (isSaving) return;
            isSaving = true;

            if (!currentAnimationId) {
                currentAnimationId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                manifest.unshift({
                    id: currentAnimationId,
                    title: "Untitled",
                    created: Date.now(),
                    modified: Date.now(),
                    frameCount: frames.length,
                    thumbnail: null
                });
            }

            // Update Manifest Item
            const item = manifest.find(m => m.id === currentAnimationId);
            if (item) {
                item.modified = Date.now();
                item.frameCount = frames.length;
                // Generate thumbnail from current frame
                await createThumbnail(currentFrameIndex).then(url => item.thumbnail = url);
            }

            // Convert ImageData frames to Base64
            const frameUrls = await Promise.all(frames.map((_, i) => createThumbnail(i)));

            const data = {
                fps: fps,
                frames: frameUrls
            };

            // Save Data
            const key = `flipnote_anim_${currentAnimationId}`;
            localStorage.setItem(key, JSON.stringify(data));

            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('flipnote_animations').doc(currentAnimationId).set(data).catch(console.error);
            }

            saveManifest();
            isSaving = false;
        }

        function isAnimationBlank() {
            // Check if all frames are blank
            // Note: This matches the "white bg" assumption of performSave/createThumbnail
            // A frame is blank if it's all white or transparent?
            // Our frames are ImageData.
            // Let's check a few pixels or look for any non-transparent/non-white pixels?
            // Since we use bufferCtx with white background logic only on export, the actual ImageData might be transparent.
            // BUT, drawing logic initializes as transparent.
            // So if all pixels are alpha=0, it's blank.
            // OR if we support white pencil on transparent bg, it's not alpha 0.

            for (let frame of frames) {
                const data = frame.data;
                for (let i = 0; i < data.length; i += 4) {
                    // Check alpha
                    if (data[i + 3] > 0) return false;
                }
            }
            return true;
        }

        function triggerAutoSave() {
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            // Don't save if blank
            if (isAnimationBlank() && !currentAnimationId) return;

            autoSaveTimer = setTimeout(() => {
                if (isAnimationBlank() && !currentAnimationId) return;
                performSave();
            }, 1000);
        }

        function createThumbnail(index) {
            return new Promise(resolve => {
                if (!frames[index]) { resolve(null); return; }
                const temp = document.createElement('canvas');
                temp.width = CANVAS_SIZE;
                temp.height = CANVAS_SIZE;
                const tx = temp.getContext('2d');

                // Draw white bg
                tx.fillStyle = 'white';
                tx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                tx.putImageData(frames[index], 0, 0);

                // If opacity/onion skin logic changes, we might need drawImage logic
                // But putImageData is raw. We need to handle transparency if frames are transparent layers.
                // Assuming white bg for output.
                // Actually putImageData replaces pixels. If frame has transparent pixels, they stay transparent?
                // No, ImageData has RGBA. 
                // We want final look. Composite over white.

                const comp = document.createElement('canvas');
                comp.width = CANVAS_SIZE;
                comp.height = CANVAS_SIZE;
                const cx = comp.getContext('2d');
                cx.fillStyle = 'white';
                cx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                cx.drawImage(temp, 0, 0); // Composite

                resolve(comp.toDataURL('image/png'));
            });
        }

        // --- DRAWING LOGIC ---
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        function startDrawing(e) {
            if (isPlaying) return;
            if (!e.isPrimary) return;
            e.preventDefault();
            isDrawing = true;

            const pos = getPointerPos(e);
            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';

            if (currentTool === 'eraser') {
                bufferCtx.globalCompositeOperation = 'destination-out';
                bufferCtx.lineWidth = 10;
            } else {
                bufferCtx.globalCompositeOperation = 'source-over';
                bufferCtx.strokeStyle = 'black';
                bufferCtx.lineWidth = 2;
            }

            bufferCtx.beginPath();
            bufferCtx.moveTo(pos.x, pos.y);
            bufferCtx.lineTo(pos.x, pos.y);
            bufferCtx.stroke();
            bufferCtx.beginPath();
            bufferCtx.moveTo(pos.x, pos.y);

            renderCanvas();
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            let events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
            for (let event of events) {
                const pos = getPointerPos(event);
                bufferCtx.lineTo(pos.x, pos.y);
            }
            bufferCtx.stroke();
            renderCanvas();
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            bufferCtx.closePath();
            saveCurrentFrame();
            triggerAutoSave();
        }

        function saveCurrentFrame() {
            if (frames[currentFrameIndex]) {
                frames[currentFrameIndex] = bufferCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
        }

        function loadCurrentFrameToBuffer() {
            bufferCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            if (frames[currentFrameIndex]) {
                bufferCtx.putImageData(frames[currentFrameIndex], 0, 0);
            }
        }

        // --- RENDERING ---
        function renderCanvas() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Onion Skin
            if (onionSkin && currentFrameIndex > 0 && !isPlaying) {
                ctx.save();
                ctx.globalAlpha = 0.2;
                const prev = frames[currentFrameIndex - 1];
                const temp = document.createElement('canvas');
                temp.width = CANVAS_SIZE;
                temp.height = CANVAS_SIZE;
                temp.getContext('2d').putImageData(prev, 0, 0);
                ctx.drawImage(temp, 0, 0);
                ctx.restore();
            }

            // Current Frame (From Buffer)
            ctx.drawImage(bufferCanvas, 0, 0);
        }

        function clearFrame() {
            if (isPlaying) stopPlaying();
            bufferCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            saveCurrentFrame();
            renderCanvas();
        }

        // --- FRAMES ---
        function prevFrame() {
            if (isPlaying) stopPlaying();
            saveCurrentFrame();
            if (currentFrameIndex > 0) {
                currentFrameIndex--;
                loadCurrentFrameToBuffer();
                renderCanvas();
                updateUI();
            }
        }

        function nextFrame() {
            if (isPlaying) stopPlaying();
            saveCurrentFrame();
            if (currentFrameIndex < frames.length - 1) {
                currentFrameIndex++;
                loadCurrentFrameToBuffer();
                renderCanvas();
                updateUI();
            }
        }

        function deleteFrame() {
            if (isPlaying) stopPlaying();
            if (frames.length <= 1) { clearFrame(); return; }
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) currentFrameIndex = frames.length - 1;
            loadCurrentFrameToBuffer();
            renderCanvas();
            updateUI();
            triggerAutoSave();
        }

        function changeSpeed() {
            const speeds = [3, 6];
            let idx = speeds.indexOf(fps);
            if (idx === -1) idx = 1;
            fps = speeds[(idx + 1) % speeds.length];
            document.getElementById('fps-btn').textContent = fps + ' FPS';
            triggerAutoSave();
        }

        // --- PLAYBACK ---
        function togglePlay() {
            if (isPlaying) stopPlaying(); else startPlaying();
        }

        function startPlaying() {
            saveCurrentFrame();
            isPlaying = true;
            // Pause Icon
            document.getElementById('play-btn').innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    <rect x="6" y="4" width="4" height="16"></rect>
                    <rect x="14" y="4" width="4" height="16"></rect>
                </svg>`;
            canvas.style.pointerEvents = 'none';
            playLoop();
        }

        function stopPlaying() {
            isPlaying = false;
            clearTimeout(playTimer);
            // Play Icon
            document.getElementById('play-btn').innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    <path d="M8 5v14l11-7z"></path>
                </svg>`;
            canvas.style.pointerEvents = 'auto';
            loadCurrentFrameToBuffer(); // Restore current frame to buffer
            renderCanvas();
        }

        function playLoop() {
            if (!isPlaying) return;

            // Draw current frame to buffer for rendering
            if (frames[currentFrameIndex]) {
                bufferCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                bufferCtx.putImageData(frames[currentFrameIndex], 0, 0);
            }

            renderCanvas();
            updateUI();

            currentFrameIndex++;
            if (currentFrameIndex >= frames.length) currentFrameIndex = 0;

            playTimer = setTimeout(playLoop, 1000 / fps);
        }

        function updateUI() {
            document.getElementById('frame-strip-visual').innerText = (window.t ? window.t('flipbook.frame_counter', "Frame {n} / {m}") : "Frame {n} / {m}").replace('{n}', currentFrameIndex + 1).replace('{m}', frames.length);
        }

        // --- HELPERS ---
        function setTool(t) {
            currentTool = t;
            document.querySelectorAll('.controls-container .sys-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(t === 'pen' ? 'tool-pen' : (t === 'eraser' ? 'tool-eraser' : '')).classList.add('active');
        }

        function openModal(id) { document.getElementById(id).style.display = 'flex'; }
        function closeModal(id) { document.getElementById(id).style.display = 'none'; }

        function showGallery() {
            if (isSaving) { triggerAutoSave(); }
            document.getElementById('screen-editor').classList.remove('active');
            document.getElementById('screen-gallery').classList.add('active');
            document.getElementById('editor-back-btn').style.display = 'none';
            renderGallery();
        }

        function showEditor() {
            document.getElementById('screen-gallery').classList.remove('active');
            document.getElementById('screen-editor').classList.add('active');
            document.getElementById('editor-back-btn').style.display = 'flex';
        }

        function handleCloseButton() {
            window.location.href = 'index';
        }

        function setupCanvas() {
            // Resize logic specialized for Flipbook
            if (!container.parentElement) return;

            const scaleStr = localStorage.getItem('rekindle_scale') || '1.0';
            const scale = parseFloat(scaleStr);

            // Reset
            container.style.width = '';
            container.style.height = '';
            container.style.zoom = '';

            const containerW = container.clientWidth;
            // The .window has max-height: 90vh. Use 90% of window height as the limit.
            const logicalWindowH = (window.innerHeight * 0.9) / scale;

            // Measure UI height dynamically
            // TitleBar (~35) + MenuBar (~30) + FrameStrip (~20) + Controls (~50) + Padding
            // We measure what we can, resort to defaults otherwise.
            const titleH = 35;
            const menuBar = document.querySelector('.menu-bar');
            const menuH = menuBar ? menuBar.offsetHeight : 30;

            // Measure controls wrapper if possible
            const controlsWrapper = document.querySelector('.controls-container');
            const controlsH = controlsWrapper ? (controlsWrapper.offsetHeight + 10) : 60; // +10 for margins

            const frameStrip = document.getElementById('frame-strip-visual');
            const stripH = frameStrip ? (frameStrip.offsetHeight + 10) : 30;

            // Padding/Margins: game-content padded 10px, canvas-container margin 10px
            // Add extra buffer for borders (4px) and shadows (4px)
            const padding = 50;

            const uiHeight = titleH + menuH + controlsH + stripH + padding;
            const availableH = logicalWindowH - uiHeight;

            // Ensure we don't go negative or too small
            const safeAvailableH = Math.max(100, availableH);

            // Container width might be constrained by parent width (also inside 90% max-width potentially)
            // But usually container.clientWidth gives us the available width in the flex column.

            const maxDimension = Math.min(containerW, safeAvailableH) * scale;
            const finalSize = Math.max(200, maxDimension);

            // Apply Inverse Scaling
            if (scale !== 1.0 && scale > 0) container.style.zoom = (1.0 / scale);

            // Adjust container size to match canvas (assume square)
            container.style.width = finalSize + 'px';
            container.style.height = finalSize + 'px';
        }

        async function downloadGIF() {
            // Use gif.js
            if (frames.length === 0) return;

            // Load worker safely to avoid cross-origin worker issues
            let workerUrl = 'gif.worker.js'; // Fallback local
            try {
                const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
                if (response.ok) {
                    const blob = await response.blob();
                    workerUrl = URL.createObjectURL(blob);
                }
            } catch (e) {
                console.warn("Could not fetch worker from CDN, trying default", e);
            }

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: CANVAS_SIZE,
                height: CANVAS_SIZE,
                workerScript: workerUrl
            });

            // Add frames
            const delay = 1000 / fps;

            // We need to render each frame to a canvas to composite over white
            // because ImageData might be transparent
            frames.forEach(frame => {
                const temp = document.createElement('canvas');
                temp.width = CANVAS_SIZE;
                temp.height = CANVAS_SIZE;
                const ctx = temp.getContext('2d');

                // White bg
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.putImageData(frame, 0, 0); // Overlay drawing

                gif.addFrame(temp, { delay: delay });
            });

            gif.on('finished', function (blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flipbook-${Date.now()}.gif`;
                a.click();
            });

            gif.render();
        }

        // --- POSTING ---
        async function confirmPost() {
            closeModal('post-confirm-modal');
            if (!currentUser) { showInfoModal("Please log in."); return; }

            // Ensure we are up to date
            await performSave();

            const animData = {
                fps: fps,
                frames: await Promise.all(frames.map((_, i) => createThumbnail(i)))
            };

            // Post to RTDB
            const messageData = {
                user: currentUser.email.split('@')[0],
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                text: "",
                is_flipnote: true,
                flipnote_data: animData,
                isPro: isPro
            };

            rtdb.ref('kindlechat/messages').push(messageData)
                .then(() => {
                    showInfoModal("Posted to KindleChat!");
                })
                .catch(e => {
                    console.error(e);
                    showInfoModal("Error posting.");
                });
        }

        function showInfoModal(msg) {
            document.getElementById('modal-message').textContent = msg;
            document.getElementById('modal-btns').innerHTML = `<button class="sys-btn" onclick="closeModal('modal-overlay')">OK</button>`;
            openModal('modal-overlay');
        }

        // --- DELETE/RENAME ---
        let deleteId = null;
        function deleteAnimation(id) {
            deleteId = id;
            document.getElementById('confirm-delete-btn').onclick = () => {
                manifest = manifest.filter(m => m.id !== id);
                localStorage.removeItem(`flipnote_anim_${id}`);
                if (currentUser) db.collection('users').doc(currentUser.uid).collection('flipnote_animations').doc(id).delete();
                saveManifest();
                renderGallery();
                closeModal('delete-modal');
            };
            openModal('delete-modal');
        }

        let renameId = null;
        function promptRename(id) {
            renameId = id;
            const item = manifest.find(m => m.id === id);
            document.getElementById('rename-input').value = item.title || 'Untitled';
            document.getElementById('confirm-rename-btn').onclick = () => {
                const val = document.getElementById('rename-input').value.trim();
                if (val) renderRename(renameId, val);
                closeModal('rename-modal');
            };
            openModal('rename-modal');
        }

        function renderRename(id, title) {
            const item = manifest.find(m => m.id === id);
            if (item) {
                item.title = title;
                item.modified = Date.now();
                saveManifest();
                renderGallery();
            }
        }

    </script>
    <script>
        function checkSubscription(user) {
            const overlay = document.getElementById('paywall-overlay');
            const status = document.getElementById('paywall-status');

            // 1. CACHE CHECK (Instant)
            try {
                const cachedExpiry = localStorage.getItem('rekindle_pro_expiry');
                if (cachedExpiry && parseInt(cachedExpiry) > Date.now()) {
                    isPro = true;
                    if (overlay) overlay.style.display = 'none';
                    // We don't return early here because we might want to refresh the cache in background
                    // but we ensure UI is unlocked.
                }
            } catch (e) { }

            if (user) {
                // Timeout fallback
                const timeoutId = setTimeout(() => {
                    console.warn("Subscription check timed out");
                    status.innerText = "Verification timed out. Please refresh.";
                    // If not already pro by cache, show overlay
                    if (!isPro) overlay.style.display = 'flex';
                }, 10000);

                db.collection('users').doc(user.uid).get()
                    .then(doc => {
                        clearTimeout(timeoutId);
                        if (doc.exists) {
                            const data = doc.data();
                            const now = Date.now();
                            let expires = 0;
                            if (data.proExpiresAt) {
                                expires = typeof data.proExpiresAt.toMillis === 'function'
                                    ? data.proExpiresAt.toMillis()
                                    : new Date(data.proExpiresAt).getTime();
                            }

                            // UPDATE CACHE
                            if (expires > now) {
                                localStorage.setItem('rekindle_pro_expiry', expires.toString());
                            } else {
                                localStorage.removeItem('rekindle_pro_expiry');
                            }

                            if (expires > now) {
                                isPro = true;
                                // Update UI if needed
                            } else {
                                isPro = false;
                            }
                        } else {
                            isPro = false;
                        }
                        // We don't force overlay here, we let actions trigger it or checks elsewhere
                        // But if we want to mimic other apps behavior of hiding overlay if pro:
                        if (isPro) {
                            if (overlay) overlay.style.display = 'none';
                        } else {
                            status.innerText = expires > 0 ? "Subscription expired." : "Subscription required.";
                            overlay.style.display = 'flex';
                        }
                    })
                    .catch(e => {
                        clearTimeout(timeoutId);
                        console.error("Error checking sub", e);
                        status.innerText = "Error verifying. Try again.";
                        overlay.style.display = 'flex';
                    });
            } else {
                // NOT LOGGED IN
                status.innerText = "Please log in.";
                overlay.style.display = 'flex';
            }
        }
    </script>
</body>

</html>