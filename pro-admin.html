<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Admin</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            font-family: "Geneva", "Verdana", sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            width: 95%;
            max-width: 800px;
            margin-top: 20px;
        }

        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            position: relative;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
        }

        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 2px 2px 0 black;
        }

        .window-content {
            padding: 20px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }

        th {
            background: #f0f0f0;
        }

        .sys-btn {
            background: white;
            border: 2px solid black;
            padding: 5px 10px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-family: inherit;
        }

        .sys-btn:active {
            box-shadow: none;
            transform: translate(1px, 1px);
        }

        .sys-btn:disabled {
            background: #f0f0f0;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }

        #status {
            margin-top: 20px;
            font-size: 0.9rem;
            white-space: pre-wrap;
            border-top: 1px dashed black;
            padding-top: 10px;
        }

        .loading {
            font-style: italic;
            color: #666;
        }
    </style>
</head>

<body>

    <div class="window">
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="window.location.href='index'">X</div>
            <span class="title-text">Pro Admin Tools</span>
        </div>
        <div class="window-content">
            <div id="auth-check">Checking authentication...</div>
            <div id="admin-panel" style="display:none;">
                <p>Welcome, <span id="admin-email" style="font-weight:bold;"></span></p>

                <div style="margin-bottom: 10px; padding: 10px; border: 1px dashed black; background: #fff;">
                    <div style="margin-bottom:5px;">
                        <label>Worker URL: <input type="text" id="worker-url" style="width: 300px;"
                                placeholder="https://rekindle-stripe.SUBDOMAIN.workers.dev"></label>
                    </div>
                    <div>
                        <label>Admin Secret: <input type="password" id="admin-token" style="width: 150px;"></label>
                        <button class="sys-btn" onclick="saveConfig()">Save Settings</button>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="sys-btn" onclick="fetchProUsers()">Fetch from Firestore</button>
                    <button class="sys-btn" onclick="fetchStripeUsers()" style="background:#e0e0ff;">Fetch from
                        Stripe</button>
                </div>

                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="sys-btn" id="tag-all-btn" onclick="tagAllProMessages()"
                        style="background: #ffff00;">Tag All Pro Messages (Automated)</button>
                    <button class="sys-btn" id="sync-sugg-btn" onclick="syncToSuggestions()"
                        style="background: #00ff00;">Sync to Suggestions App</button>
                </div>

                <table id="pro-users-table">
                    <thead>
                        <tr>
                            <th>User (UID)</th>
                            <th>Resolved Username</th>
                            <th>Expiry / Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="pro-users-list">
                        <!-- Filled by JS -->
                    </tbody>
                </table>
                <div id="status"></div>

                <div id="debug-panel"
                    style="margin-top: 20px; padding: 10px; border: 1px dashed red; font-size: 0.8rem; background: #fff0f0; display: none;">
                    <strong>Debug Info:</strong>
                    <div id="debug-content">No debug data yet.</div>
                    <button class="sys-btn" onclick="dumpCache()" style="margin-top: 5px; font-size: 0.7rem;">Dump Auth
                        Cache</button>
                    <button class="sys-btn" onclick="this.parentElement.style.display='none'"
                        style="margin-top: 5px; font-size: 0.7rem;">Close</button>
                </div>
                <button class="sys-btn" onclick="document.getElementById('debug-panel').style.display='block'"
                    style="margin-top: 10px; font-size: 0.7rem; opacity: 0.5;">Show Debug</button>
            </div>
        </div>
    </div>

    <script>
        // Default placeholder, overwritten by input
        const DEFAULT_WORKER_URL = "https://rekindle-stripe.timjarnott.workers.dev";

        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77",
            databaseURL: "https://rekindle-dd1fa-default-rtdb.firebaseio.com/"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const rtdb = firebase.database();

        // Load Config
        window.onload = function () {
            const savedToken = localStorage.getItem('rekindle_admin_token');
            if (savedToken) document.getElementById('admin-token').value = savedToken;

            const savedUrl = localStorage.getItem('rekindle_worker_url');
            if (savedUrl) {
                document.getElementById('worker-url').value = savedUrl;
            } else {
                document.getElementById('worker-url').value = DEFAULT_WORKER_URL;
            }
        };

        function saveConfig() {
            const token = document.getElementById('admin-token').value;
            const url = document.getElementById('worker-url').value.replace(/\/$/, ""); // remove trailing slash

            localStorage.setItem('rekindle_admin_token', token);
            localStorage.setItem('rekindle_worker_url', url);
            alert("Settings saved.");
        }

        auth.onAuthStateChanged(user => {
            if (user && user.email === 'ukiyo@rekindle.ink') {
                document.getElementById('auth-check').style.display = 'none';
                document.getElementById('admin-panel').style.display = 'block';
                document.getElementById('admin-email').textContent = user.email;
                // fetchProUsers(); // Don't auto-fetch, let user choose source
            } else if (user) {
                document.getElementById('auth-check').textContent = 'Unauthorized: Only ukiyo@rekindle.ink can access this page.';
                document.getElementById('auth-check').style.color = 'red';
            } else {
                window.location.href = 'index';
            }
        });

        let discoveredProUsers = [];

        async function fetchStripeUsers() {
            const list = document.getElementById('pro-users-list');
            list.innerHTML = '<tr><td colspan="4" class="loading">Fetching active subscribers from Stripe...</td></tr>';
            discoveredProUsers = [];

            const token = document.getElementById('admin-token').value;
            let workerUrl = document.getElementById('worker-url').value.trim();

            if (!token) {
                list.innerHTML = `<tr><td colspan="4" style="color:red;">Error: Admin Secret is missing.</td></tr>`;
                alert("Please enter the Admin Secret.");
                return;
            }

            // Basic validation and formatting
            if (!workerUrl) {
                list.innerHTML = `<tr><td colspan="4" style="color:red;">Error: Worker URL is missing.</td></tr>`;
                return;
            }
            // Ensure protocol
            if (!workerUrl.startsWith("http://") && !workerUrl.startsWith("https://")) {
                workerUrl = "https://" + workerUrl;
            }
            // Strip trailing slash if present
            workerUrl = workerUrl.replace(/\/$/, "");

            // Update input to reflect corrected URL for user clarity
            document.getElementById('worker-url').value = workerUrl;

            try {
                console.log(`Attempting to fetch from: ${workerUrl}/subscribers`);
                const res = await fetch(`${workerUrl}/subscribers`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!res.ok) throw new Error(await res.text());

                const users = await res.json();

                if (users.length === 0) {
                    list.innerHTML = '<tr><td colspan="4">No active Stripe subscribers found.</td></tr>';
                    return;
                }

                // Pre-fetch Firebase Auth displayNames for all users
                const uids = users.map(u => u.uid).filter(uid => uid);
                if (uids.length > 0) {
                    list.innerHTML = '<tr><td colspan="4">Resolving usernames from Firebase Auth...</td></tr>';
                    await batchResolveFirebaseAuth(uids);
                }

                renderUsers(users.map(u => ({
                    uid: u.uid || "Unknown UID",
                    email: u.email || null,
                    expiry: u.created ? new Date(u.created * 1000) : null,
                    type: u.type || "Unknown",
                    source: 'stripe'
                })));

            } catch (err) {
                console.error(err);
                let msg = err.message;
                if (msg.includes("Load failed") || msg.includes("hostname")) {
                    msg += " <br><b>Possible Cause:</b> Incorrect Worker URL or Worker is down. Please verify the URL above.";
                }
                list.innerHTML = `<tr><td colspan="4" style="color:red;">Error fetching Stripe: ${msg}</td></tr>`;
                alert("Connection failed! Please check that your Worker URL is correct:\n" + workerUrl);
            }
        }

        async function fetchProUsers() {
            const list = document.getElementById('pro-users-list');
            list.innerHTML = '<tr><td colspan="4" class="loading">Scanning Firestore for Pro users...</td></tr>';
            discoveredProUsers = [];

            try {
                const now = new Date();
                const snapshot = await db.collection('users')
                    .where('proExpiresAt', '>', now)
                    .get();

                if (snapshot.empty) {
                    list.innerHTML = '<tr><td colspan="4">No active Pro users found in Firestore.</td></tr>';
                    return;
                }

                const proUsers = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    proUsers.push({
                        uid: doc.id,
                        email: data.email || "",
                        expiry: data.proExpiresAt ? data.proExpiresAt.toDate() : null,
                        source: 'firestore'
                    });
                });

                if (proUsers.length > 0) {
                    list.innerHTML = '<tr><td colspan="4" class="loading">Resolving identities from Firebase Auth...</td></tr>';
                    const uids = proUsers.map(u => u.uid).filter(uid => uid);
                    await batchResolveFirebaseAuth(uids);
                }

                renderUsers(proUsers);

            } catch (err) {
                console.error("Error fetching Pro users:", err);
                list.innerHTML = `<tr><td colspan="4" style="color:red;">Error: ${err.message}</td></tr>`;
            }
        }

        function renderUsers(users) {
            const list = document.getElementById('pro-users-list');
            list.innerHTML = '';

            // Store full objects for sync logic
            discoveredProUsers = users.filter(u => u.uid !== "Unknown UID");

            for (const user of users) {
                const tr = document.createElement('tr');
                tr.id = `row-${user.uid}`;
                const sourceBadge = user.source === 'stripe' ? '<span style="background:purple;color:white;padding:2px;font-size:0.6rem;">STRIPE</span>' : '<span style="background:orange;color:black;padding:2px;font-size:0.6rem;">FS</span>';

                tr.innerHTML = `
                    <td>
                        <div style="font-weight:bold;">${user.email || "No Email"} ${sourceBadge}</div>
                        <div style="font-size:0.7rem; color:#666;">UID: ${user.uid}</div>
                    </td>
                    <td id="username-cell-${user.uid}">
                        <input type="text" id="input-${user.uid}" class="loading" value="Resolving..." style="width:120px; padding:2px; font-family:inherit;">
                    </td>
                    <td>${user.expiry ? user.expiry.toLocaleDateString() : "N/A"}</td>
                    <td>
                        <button class="sys-btn" onclick="tagMessagesForUser('${user.uid}')">Tag Theirs</button>
                    </td>
                `;
                list.appendChild(tr);

                // Start background resolution
                resolveUsername(user).then(result => {
                    console.log(`Resolved ${user.uid}:`, result);
                    const input = document.getElementById(`input-${user.uid}`);
                    if (input) {
                        input.value = result.username || user.uid;
                        input.classList.remove('loading');
                        // Mark unreliable sources (not from Firebase Auth or Firestore user doc) in red
                        if (!result.reliable) {
                            input.style.color = 'red';
                            input.title = `Source: ${result.source} - Username not from Firebase Auth or user profile`;
                        } else {
                            input.style.color = 'black';
                            input.title = `Source: ${result.source}`;
                        }
                    }
                });
            }
        }

        // Cache for resolved Firebase Auth users (avoids repeated API calls)
        let firebaseAuthCache = {};

        async function resolveUsername(user) {
            // Priority 1: Check cache first (Firebase Auth displayName)
            if (firebaseAuthCache[user.uid]) {
                const cached = firebaseAuthCache[user.uid];
                if (cached.displayName) return { username: cached.displayName, reliable: true, source: 'Firebase Auth' };
            }

            // Priority 2: Firestore User Profile (Official Username in DB)
            try {
                const userDoc = await db.collection('users').doc(user.uid).get();
                if (userDoc.exists) {
                    const data = userDoc.data();
                    if (data.username) {
                        console.log(`Firestore username found for ${user.uid}: ${data.username}`);
                        return { username: data.username, reliable: true, source: 'Firestore (username)' };
                    }
                    if (data.displayName) {
                        console.log(`Firestore displayName found for ${user.uid}: ${data.displayName}`);
                        return { username: data.displayName, reliable: true, source: 'Firestore (displayName)' };
                    }
                }
            } catch (e) {
                console.warn(`Profile fetch failed for ${user.uid}:`, e);
            }

            // Priority 3: Check leaderboards (User-chosen names in games)
            const collections = [
                'leaderboard_tetris', 'leaderboard_snake', 'leaderboard_dino_v1',
                'leaderboard_hanoi_3', 'leaderboard_lightsout_3',
                'leaderboard_trivia', 'leaderboard_solitaire', 'leaderboard_blockblast'
            ];

            for (const col of collections) {
                try {
                    const doc = await db.collection(col).doc(user.uid).get();
                    if (doc.exists && doc.data().username) {
                        console.log(`Leaderboard ${col} name found for ${user.uid}: ${doc.data().username}`);
                        return { username: doc.data().username, reliable: true, source: `Leaderboard (${col})` };
                    }
                } catch (e) { /* ignore */ }
            }

            // Priority 4: Check Suggestions (User-chosen name in feedback)
            try {
                const snapshot = await db.collection('suggestions')
                    .where('authorUid', '==', user.uid)
                    .limit(1)
                    .get();
                if (!snapshot.empty) {
                    return { username: snapshot.docs[0].data().author, reliable: true, source: 'Suggestions' };
                }
            } catch (e) { /* ignore */ }

            // --- LOWER RELIABILITY SOURCES (Stripe Data) ---

            // Priority 5: Stripe Name (If available in Checkout Session)
            if (user.name) return { username: user.name, reliable: false, source: 'Stripe Name' };

            // Priority 6: Email prefix (Default fallback)
            if (user.email) return { username: user.email.split('@')[0], reliable: false, source: 'Email Prefix (Unreliable)' };

            return { username: user.uid, reliable: false, source: 'UID Fallback' };
        }

        // Batch resolve Firebase Auth users (call once after fetching subscribers)
        async function batchResolveFirebaseAuth(uids) {
            const workerUrl = document.getElementById('worker-url').value.replace(/\/$/, "");
            const token = document.getElementById('admin-token').value;
            const debug = document.getElementById('debug-content');

            try {
                if (debug) debug.innerHTML = `<div>Resolving ${uids.length} UIDs...</div>`;

                const res = await fetch(`${workerUrl}/resolve-users`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ uids })
                });

                if (res.ok) {
                    const resolved = await res.json();
                    console.log("Batch Resolved Data:", resolved);
                    if (debug) debug.innerHTML += `<div>Worker resolved ${resolved.length} users.</div>`;

                    let foundNames = 0;
                    for (const user of resolved) {
                        firebaseAuthCache[user.uid] = user;
                        if (user.displayName) foundNames++;
                    }
                    if (debug) debug.innerHTML += `<div>DisplayNames found in Auth: ${foundNames}</div>`;
                    console.log("Batch resolved", resolved.length, "Firebase Auth users");
                } else {
                    const errorMsg = await res.text();
                    console.error("Batch resolve HTTP error:", res.status, errorMsg);
                    if (debug) debug.innerHTML += `<div style="color:red;">Worker Error (${res.status}): ${errorMsg}</div>`;
                    document.getElementById('status').textContent += `\nWarning: Identity resolution failed (${res.status}). Usernames may be unreliable.\n`;
                }
            } catch (e) {
                console.warn("Batch resolve failed:", e);
                if (debug) debug.innerHTML += `<div style="color:red;">Network Error: ${e.message}</div>`;
                document.getElementById('status').textContent += `\nWarning: Network error resolving identities. Usernames may be unreliable.\n`;
            }
        }

        function dumpCache() {
            const debug = document.getElementById('debug-content');
            debug.innerHTML = `<strong>Cache Content (${Object.keys(firebaseAuthCache).length} items):</strong><pre>` +
                JSON.stringify(firebaseAuthCache, null, 2) + "</pre>";
        }

        async function syncToSuggestions() {
            const btn = document.getElementById('sync-sugg-btn');
            const status = document.getElementById('status');
            btn.disabled = true;
            status.textContent += "\nSyncing Pro users to Suggestions App (config/supporters)...\n";

            try {
                if (discoveredProUsers.length === 0) {
                    status.textContent += "Error: No Pro users found to sync. Refresh list first.\n";
                    btn.disabled = false;
                    return;
                }

                // Gather full user data with resolved usernames
                const proUserData = [];
                for (const user of discoveredProUsers) {
                    const input = document.getElementById(`input-${user.uid}`);
                    const resolvedName = (input && input.value !== 'Resolving...' && input.value.trim() !== '')
                        ? input.value.trim()
                        : user.uid;

                    proUserData.push({
                        uid: user.uid,
                        username: resolvedName,
                        expiresAt: user.expiry ? user.expiry.toISOString() : null,
                        type: user.type,
                        isLifetime: user.type === 'lifetime'
                    });
                }

                // Call worker to perform the bulk sync
                const workerUrl = document.getElementById('worker-url').value.replace(/\/$/, "");
                const token = document.getElementById('admin-token').value;

                status.textContent += `Sending ${proUserData.length} users to worker at ${workerUrl}...\n`;

                const res = await fetch(`${workerUrl}/sync-pro-users`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ users: proUserData })
                });

                if (!res.ok) throw new Error(await res.text());

                const result = await res.json();
                status.textContent += `Success: Worker synced ${result.count} Pro users to config/supporters document.\n`;

            } catch (err) {
                console.error("Error syncing to suggestions:", err);
                status.textContent += `Error syncing: ${err.message}\n`;
            }
            btn.disabled = false;
        }

        async function tagAllProMessages() {
            const btn = document.getElementById('tag-all-btn');
            const status = document.getElementById('status');
            btn.disabled = true;
            status.textContent = "Starting bulk tagging operation...\n";

            if (discoveredProUsers.length === 0) {
                status.textContent += "Error: No Pro users loaded. Fetch from Stripe or Firestore first.\n";
                btn.disabled = false;
                return;
            }

            let totalTagged = 0;

            for (const user of discoveredProUsers) {
                const uid = user.uid;
                const input = document.getElementById(`input-${uid}`);
                const username = input ? input.value.trim() : null;

                if (!username || username === uid || username === "Resolving...") {
                    status.textContent += `Skipping ${uid} (no resolved username)...\n`;
                    continue;
                }

                status.textContent += `Tagging messages for "${username}"...\n`;
                const count = await tagMessages(uid, username);
                totalTagged += count;
            }

            status.textContent += `\nDONE! Tagged ${totalTagged} messages across ${discoveredProUsers.length} Pro users.`;
            btn.disabled = false;
        }

        async function tagMessagesForUser(uid) {
            const input = document.getElementById(`input-${uid}`);
            const username = input ? input.value.trim() : null;
            await tagMessages(uid, username);
        }

        async function tagMessages(uid, username) {
            const status = document.getElementById('status');
            const candidates = new Set();
            if (uid) candidates.add(uid);
            if (username) candidates.add(username);

            let taggedForThisUser = 0;

            for (const name of candidates) {
                try {
                    const messagesRef = rtdb.ref('kindlechat/messages');
                    const snapshot = await messagesRef.orderByChild('user').equalTo(name).once('value');

                    if (snapshot.exists()) {
                        const updates = {};
                        let count = 0;
                        snapshot.forEach(child => {
                            if (!child.val().isPro) {
                                updates[`${child.key}/isPro`] = true;
                                count++;
                            }
                        });

                        if (count > 0) {
                            await messagesRef.update(updates);
                            taggedForThisUser += count;
                        }
                    }
                } catch (err) {
                    console.error(`Error tagging for ${name}: `, err);
                }
            }

            status.textContent += `> Tagged ${taggedForThisUser} messages for user/uid.\n`;
            return taggedForThisUser;
        }
    </script>
</body>

</html>