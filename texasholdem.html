<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Texas Hold'em</title>
    <style>
        /* SYSTEM 7 AESTHETICS - Shared with Blackjack */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
            --card-width: 50px;
            --card-height: 70px;
        }

        body {
            image-rendering: pixelated;
            /* Universal pixelated for retro feel */
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            height: 95vh;
            width: 95%;
            max-width: 800px;
            /* Wider for poker table */
            position: relative;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* GAME TABLE */
        .window-content {
            flex-grow: 1;
            padding: 10px;
            background: white;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* POKER TABLE LAYOUT */
        .poker-table {
            flex-grow: 1;
            border: 2px dashed #ccc;
            border-radius: 40px;
            position: relative;
            margin: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* COMMUNITY CARDS */
        .community-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 100px;
        }

        .pot-display {
            font-family: "Courier New", monospace;
            font-weight: bold;
            font-size: 1.2rem;
            border: 2px solid black;
            padding: 5px 15px;
            background: #eee;
            box-shadow: 2px 2px 0 #aaa;
        }

        /* CARD STYLES */
        .cards-row {
            display: flex;
            gap: 5px;
            justify-content: center;
            min-height: var(--card-height);
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px solid black;
            border-radius: 4px;
            background: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2px;
            /* Smaller padding for smaller cards */
            box-sizing: border-box;
            box-shadow: 2px 2px 0 #ccc;
            font-family: "Courier New", monospace;
            font-weight: bold;
            position: relative;
            font-size: 0.8rem;
        }

        .card.back {
            background-image: repeating-linear-gradient(45deg, black 0, black 2px, white 2px, white 4px);
            background-size: 6px 6px;
        }

        .suit-red {
            color: white;
            -webkit-text-stroke: 1px black;
            text-shadow: 1px 1px 0 #000;
        }

        /* Improved visibility for red */
        .suit-black {
            color: black;
        }

        .card-center-suit {
            font-size: 1.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* PLAYERS */
        .player-seat {
            position: absolute;
            width: 120px;
            height: 100px;
            border: 2px solid black;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.1);
        }

        .player-seat.active-turn {
            box-shadow: 0 0 0 3px black;
        }

        .player-seat.folded {
            opacity: 0.5;
        }

        .player-seat.winner {
            border: 4px double black;
        }

        /* Positioning Seats around the table */
        /* Assuming 5 seats: TopLeft, TopRight, Left, Right, Bottom(User) */
        /* For 4 players (User + 3 AI): Top, Left, Right, Bottom */

        .seat-top {
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
        }

        .seat-left {
            top: 50%;
            left: -10px;
            transform: translateY(-50%);
        }

        .seat-right {
            top: 50%;
            right: -10px;
            transform: translateY(-50%);
        }

        .seat-user {
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 140px;
        }

        /* Larger for user */

        .seat-name {
            font-weight: bold;
            font-size: 0.9rem;
            border-bottom: 1px solid #aaa;
            width: 100%;
            text-align: center;
        }

        .seat-chips {
            font-family: "Courier New", monospace;
            font-size: 0.8rem;
        }

        .seat-action {
            font-style: italic;
            font-size: 0.8rem;
            min-height: 1.2em;
        }

        .user-controls {
            display: none;
            /* Flex when active */
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin-top: 5px;
            width: 100%;
        }

        .sys-btn {
            background: white;
            border: 2px solid black;
            padding: 5px 10px;
            font-weight: bold;
            font-size: 0.8rem;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
        }

        .sys-btn:active {
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0 black;
        }

        .sys-btn:disabled {
            opacity: 0.3;
            cursor: default;
            box-shadow: none;
        }

        /* NOTIFICATIONS */
        #game-message {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid black;
            padding: 10px 20px;
            z-index: 10;
            font-weight: bold;
            box-shadow: 4px 4px 0 black;
            display: none;
            text-align: center;
        }
    </style>
    <script src="theme.js"></script>
</head>

<body>

    <div class="window">
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="window.location.href='index'">X</div>
            <span class="title-text">Texas Hold'em</span>
        </div>

        <div class="window-content">

            <div class="poker-table">
                <!-- Community Cards & Pot -->
                <div class="community-area">
                    <div class="pot-display">Pot: $<span id="pot-amount">0</span></div>
                    <div class="cards-row" id="community-cards">
                        <!-- <div class="card back"></div>
                        <div class="card back"></div>
                        <div class="card back"></div> -->
                    </div>
                </div>

                <!-- Opponents -->
                <div class="player-seat seat-top" id="seat-1">
                    <div class="seat-name">Bot 1</div>
                    <div class="seat-chips">$1000</div>
                    <div class="cards-row op-cards">
                        <div class="card back" style="width:30px; height:42px;"></div>
                        <div class="card back" style="width:30px; height:42px;"></div>
                    </div>
                    <div class="seat-action"></div>
                </div>

                <div class="player-seat seat-left" id="seat-2">
                    <div class="seat-name">Bot 2</div>
                    <div class="seat-chips">$1000</div>
                    <div class="cards-row op-cards">
                        <div class="card back" style="width:30px; height:42px;"></div>
                        <div class="card back" style="width:30px; height:42px;"></div>
                    </div>
                    <div class="seat-action"></div>
                </div>

                <div class="player-seat seat-right" id="seat-3">
                    <div class="seat-name">Bot 3</div>
                    <div class="seat-chips">$1000</div>
                    <div class="cards-row op-cards">
                        <div class="card back" style="width:30px; height:42px;"></div>
                        <div class="card back" style="width:30px; height:42px;"></div>
                    </div>
                    <div class="seat-action"></div>
                </div>

                <!-- User -->
                <div class="player-seat seat-user" id="seat-0">
                    <div class="seat-name">You <span id="dealer-btn" style="display:none; color:red;">(D)</span></div>
                    <div class="seat-chips" id="user-chips">$1000</div>
                    <div class="cards-row" id="user-cards">
                        <!-- Cards dealt here -->
                    </div>
                    <div class="seat-action" id="user-action-text"></div>

                    <div class="user-controls" id="user-controls">
                        <button class="sys-btn" onclick="game.playerAction('fold')">Fold</button>
                        <button class="sys-btn" onclick="game.playerAction('check')" id="btn-check">Check</button>
                        <button class="sys-btn" onclick="game.playerAction('call')" id="btn-call">Call</button>
                        <button class="sys-btn" onclick="game.playerAction('raise')" id="btn-raise">Raise</button>
                    </div>
                </div>

            </div>

            <div id="game-message"></div>
            <button class="sys-btn" id="start-btn" onclick="game.startRound()"
                style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:200px; height:40px; font-size:1.2rem; z-index:20;">Start
                Game</button>

        </div>
    </div>

    <script>
        // --- GAME CONSTANTS & UTILS ---
        const SUITS = ['♠', '♥', '♣', '♦']; // Spades, Hearts, Clubs, Diamonds
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        function wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        // --- CLASSES ---

        class Card {
            constructor(suit, val) {
                this.suit = suit;
                this.val = val;
            }

            get rank() { return VALUES.indexOf(this.val); } // 0-12

            toString() { return `${this.val}${this.suit}`; }

            render(hidden = false) {
                const div = document.createElement('div');
                div.className = 'card';
                if (hidden) {
                    div.className += ' back';
                    return div;
                }

                const isRed = (this.suit === '♥' || this.suit === '♦');
                const suitClass = isRed ? 'suit-red' : 'suit-black';

                div.innerHTML = `
                    <div style="font-size:0.8em; line-height:1;" class="${suitClass}">${this.val}<br>${this.suit}</div>
                    <div class="card-center-suit ${suitClass}">${this.suit}</div>
                `;
                return div;
            }
        }

        class Deck {
            constructor() {
                this.cards = [];
                for (let s of SUITS) {
                    for (let v of VALUES) {
                        this.cards.push(new Card(s, v));
                    }
                }
                this.shuffle();
            }

            shuffle() {
                this.cards.sort(() => Math.random() - 0.5);
            }

            deal() {
                return this.cards.pop();
            }
        }

        class Player {
            constructor(id, name, chips, isHuman = false) {
                this.id = id;
                this.name = name;
                this.chips = chips;
                this.isHuman = isHuman;
                this.hand = [];
                this.folded = false;
                this.currentBet = 0; // Amount bet in current street
                this.isAllIn = false;
            }

            resetForRound() {
                this.hand = [];
                this.folded = false;
                this.currentBet = 0;
                this.isAllIn = false;
            }
        }

        // --- HAND EVALUATOR ---

        class HandEvaluator {
            static getRankValue(card) {
                return VALUES.indexOf(card.val);
            }

            static evaluate(cards) {
                // Returns { score: numeric_score, name: string_description }
                // Score = (RankClass * 1000000) + (HighCardValues...)
                // RankClass: 8=StrFlush, 7=Quads, 6=FullHouse, 5=Flush, 4=Straight, 3=Trips, 2=TwoPair, 1=Pair, 0=HighCard

                if (cards.length < 5) return { score: 0, name: "Incomplete" };

                // Get all 7 cards (2 hole + 5 community), or just evaluate what's passed (usually 7)
                // We need to find the BEST 5 card combination from the input cards.
                // Combinations of 5 from N.

                // Helper to get all combinations of 5 cards
                const getCombinations = (arr, k) => {
                    if (k === 0) return [[]];
                    if (arr.length === 0) return [];
                    const [first, ...rest] = arr;
                    const combsWithFirst = getCombinations(rest, k - 1).map(c => [first, ...c]);
                    const combsWithoutFirst = getCombinations(rest, k);
                    return [...combsWithFirst, ...combsWithoutFirst];
                };

                const possibleHands = getCombinations(cards, 5);
                let bestHand = { score: -1, name: "" };

                for (let hand of possibleHands) {
                    const res = HandEvaluator.score5CardHand(hand);
                    if (res.score > bestHand.score) {
                        bestHand = res;
                    }
                }
                return bestHand;
            }

            static score5CardHand(hand) {
                // Sort by rank descending
                hand.sort((a, b) => HandEvaluator.getRankValue(b) - HandEvaluator.getRankValue(a));

                const ranks = hand.map(c => HandEvaluator.getRankValue(c));
                const suits = hand.map(c => c.suit);

                const isFlush = suits.every(s => s === suits[0]);

                // Check Straight
                let isStraight = true;
                for (let i = 0; i < 4; i++) {
                    if (ranks[i] - ranks[i + 1] !== 1) {
                        isStraight = false;
                        break;
                    }
                }
                // Wheel Straight (A, 5, 4, 3, 2) -> Ranks: 12, 3, 2, 1, 0
                if (!isStraight && ranks[0] === 12 && ranks[1] === 3 && ranks[2] === 2 && ranks[3] === 1 && ranks[4] === 0) {
                    isStraight = true;
                    // Treat as 5-high straight
                }

                const rankCounts = {};
                ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
                const counts = Object.values(rankCounts).sort((a, b) => b - a); // e.g. [3, 2] for full house

                let score = 0;
                let name = "";
                let baseScore = 0;

                // Base score from kickers (lexicographical)
                // We assume max 5 cards. digit weights: 14^4, 14^3... 
                ranks.forEach((r, i) => {
                    baseScore += r * Math.pow(15, 4 - i); // Base 15 to be safe
                });

                if (isStraight && isFlush) {
                    score = 8000000 + baseScore;
                    name = "Straight Flush";
                } else if (counts[0] === 4) {
                    // Quads. Need to prioritize Quad rank then kicker.
                    const quadRank = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 4));
                    const kicker = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 1));
                    score = 7000000 + (quadRank * 100000) + kicker;
                    name = "Four of a Kind";
                } else if (counts[0] === 3 && counts[1] === 2) {
                    const tripRank = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 3));
                    const pairRank = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 2));
                    score = 6000000 + (tripRank * 100000) + pairRank;
                    name = "Full House";
                } else if (isFlush) {
                    score = 5000000 + baseScore;
                    name = "Flush";
                } else if (isStraight) {
                    score = 4000000 + baseScore;
                    name = "Straight";
                } else if (counts[0] === 3) {
                    const tripRank = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 3));
                    // Remaining kickers
                    const kickers = ranks.filter(r => r !== tripRank);
                    score = 3000000 + (tripRank * 100000) + (kickers[0] * 1000) + kickers[1];
                    name = "Three of a Kind";
                } else if (counts[0] === 2 && counts[1] === 2) {
                    // Two Pair
                    const pairRanks = Object.keys(rankCounts).filter(r => rankCounts[r] === 2).map(Number).sort((a, b) => b - a);
                    const kicker = Object.keys(rankCounts).find(r => rankCounts[r] === 1);
                    score = 2000000 + (pairRanks[0] * 100000) + (pairRanks[1] * 1000) + Number(kicker);
                    name = "Two Pair";
                } else if (counts[0] === 2) {
                    // Pair
                    const pairRank = parseInt(Object.keys(rankCounts).find(r => rankCounts[r] === 2));
                    const kickers = ranks.filter(r => r !== pairRank);
                    score = 1000000 + (pairRank * 100000) + (kickers[0] * 1000) + (kickers[1] * 10) + kickers[2]; // Approximation
                    name = "Pair";
                } else {
                    score = baseScore;
                    name = "High Card";
                }

                return { score, name };
            }
        }

        // --- GAME ENGINE ---

        class TexasHoldEm {
            constructor() {
                this.players = [
                    new Player(0, "You", 1000, true),
                    new Player(1, "Bot 1", 1000),
                    new Player(2, "Bot 2", 1000),
                    new Player(3, "Bot 3", 1000)
                ];

                this.deck = null;
                this.communityCards = [];
                this.pot = 0;
                this.dealerIdx = 0;
                this.currentTurnIdx = 0;
                this.smallBlind = 10;
                this.bigBlind = 20;
                this.minBet = 20; // Current highest bet to call
                this.stage = 'idle';

                // Betting State
                this.activePlayers = []; // Indexes of players still in hand
                this.lastAggressorIdx = -1; // Index of last fundraiser
                this.bettingComplete = false;
            }

            async startRound() {
                document.getElementById('start-btn').style.display = 'none';
                document.getElementById('game-message').style.display = 'none';

                this.deck = new Deck();
                this.communityCards = [];
                this.pot = 0;
                this.stage = 'preflop';

                // Rotate dealer
                this.dealerIdx = (this.dealerIdx + 1) % 4;

                this.players.forEach(p => p.resetForRound());
                this.activePlayers = [0, 1, 2, 3];

                // Post Blinds
                const sbIdx = (this.dealerIdx + 1) % 4;
                const bbIdx = (this.dealerIdx + 2) % 4;

                this.postBlind(sbIdx, this.smallBlind);
                this.postBlind(bbIdx, this.bigBlind);

                this.minBet = this.bigBlind;
                this.lastAggressorIdx = bbIdx; // Betting ends if it comes back to BB and they check, or first caller?
                // Actually, standard rule: ends when all match max bet. 
                // Initial aggressor is effectively BB.
                // But BB has option to raise. So let's track the "stopper" index.

                // Deal Hole Cards
                for (let i = 0; i < 2; i++) {
                    this.players.forEach(p => p.hand.push(this.deck.deal()));
                }

                this.updateUI();

                // Start betting
                // Turn starts after BB
                this.currentTurnIdx = (bbIdx + 1) % 4;
                this.bettingComplete = false;

                await this.gameLoop();
            }

            postBlind(playerIdx, amount) {
                const p = this.players[playerIdx];
                const actual = Math.min(p.chips, amount);
                p.chips -= actual;
                p.currentBet = actual;
                this.pot += actual;
                this.log(`${p.name} posts blind $${actual}`);
            }

            async gameLoop() {
                // Main loop driving the phases
                while (this.stage !== 'gameover') {

                    if (!this.bettingComplete) {
                        // Check if only one player left
                        if (this.activePlayers.length === 1) {
                            this.endRound();
                            return;
                        }

                        // Play Turn
                        const pIdx = this.currentTurnIdx;
                        const p = this.players[pIdx];

                        // Skip folded or all-in players (unless all-in logic needs attention, but usually skipped for action)
                        if (p.folded || p.isAllIn) {
                            this.advanceTurn();
                            continue;
                        }

                        this.updateUI(); // Highlight active

                        if (p.isHuman) {
                            this.enableUserControls();
                            return; // Break loop, wait for USER_ACTION event
                        } else {
                            await wait(800);
                            this.processBotTurn(p);
                        }
                    } else {
                        // Move to next stage
                        await this.advanceStage();
                    }

                    // Safety break
                    await wait(50);
                }
            }

            advanceTurn() {
                // Check if betting round is done BEFORE moving index?
                // Logic: A complete round means everyone has had a chance to act AND matched the bet.

                // Check if we reached the stopper?
                // Better approach:
                // Check if all active players match the current minBet (or are all-in)
                // AND (everyone has acted at least once OR it's preflop and BB option used)

                // Simplified Logic: 
                // If next player is the LastAggressor, betting is done? 
                // Wait, if I raise, everyone calls, it comes back to me. I don't act again unless re-raised.

                // Let's use 'lastActionIdx'.
                // If we iterate full circle to the last person who raised (or BB initially), and they don't raise again, we are done.

                this.currentTurnIdx = (this.currentTurnIdx + 1) % 4;

                // Check completion condition
                const active = this.players.filter(p => !p.folded && !p.isAllIn);
                const allMatched = active.every(p => p.currentBet === this.minBet);

                // If all matched, and we went past the last aggressor...
                // This is tricky to do purely iteratively without state flags.
                // Let's rely on explicit "isBettingClosed" check.

                if (active.length === 0) {
                    this.bettingComplete = true; // Everyone all in
                    this.gameLoop();
                    return;
                }

                // If we are back to the person who made the last aggressive action (raise/post), 
                // AND everyone in between has called/folded.
                // Actually, just check: Is the NEXT player the LastAggressor? 
                // If YES, and they matched (which they must have, they set it), then done.

                // Special case: Big Blind Preflop has "Option".
                // If it comes back to BB and no raises, BB gets to act.
                // LastAggressor logic covers this if we set LastAggressor = BB initially.
                // But BB needs to act. So we only stop if we PASS the LastAggressor?

                // ... Let's just track "actions_left".
                // This is easier.
            }

            // Re-implementing simplified turn logic
            // We'll track 'playersToAct' list? Or just check condition after every action.

            actionComplete(p, action) {
                // Logic after ANY action (Human or Bot)

                // 1. Move index
                let nextIdx = (this.currentTurnIdx + 1) % 4;

                // 2. Check if betting round end
                // Condition: All active players have bet === minBet (or allin)
                // AND everyone has had a chance (we assume active play continues until equalized).
                // Issue: BB preflop option.

                // Let's use a simpler heuristic for V1:
                // If (nextIdx == this.lastAggressorIdx) AND (everyone matches), then Next Stage.
                // Exception: Preflop, LastAggressor is initially BB. If it comes back to BB and bets are equal, BB gets option.
                // If BB checks, then round over. If BB raises, LastAggressor moves.

                const active = this.players.filter(x => !x.folded && !x.isAllIn);
                const allMatched = active.every(x => x.currentBet === this.minBet);

                if (allMatched && this.currentTurnIdx === this.lastAggressorIdx) {
                    // Round likely over.
                    // Exception: Preflop Option. 
                    if (this.stage === 'preflop' && this.minBet === this.bigBlind && p.id === this.players[(this.dealerIdx + 2) % 4].id && action === 'check') {
                        // BB Checked their option. Done.
                        this.bettingComplete = true;
                    }
                    else if (this.stage === 'preflop' && this.minBet === this.bigBlind && this.currentTurnIdx === (this.dealerIdx + 2) % 4) {
                        // It is BB turn, bets are equal. Wait for their action. (They haven't acted yet in this flow if we are checking BEFORE move?)
                        // No, this func is called AFTER action.
                        // If BB just checked -> Done.
                        // If BB raised -> Not Done.
                        if (action !== 'raise') this.bettingComplete = true;
                    }
                    else {
                        this.bettingComplete = true;
                    }
                }

                if (this.bettingComplete) {
                    this.gameLoop(); // Will trigger advanceStage
                } else {
                    this.currentTurnIdx = nextIdx;
                    this.gameLoop(); // Continue betting
                }
            }

            processBotTurn(bot) {
                // Heuristic
                // Random action weighted by strength?
                // For V1: Simple.
                // If bet > 0: 80% Call, 20% Fold. (If Call too high compared to chips? Fold).
                // If bet == 0: 90% Check, 10% Bet.

                const toCall = this.minBet - bot.currentBet;
                let action = 'fold';

                if (toCall === 0) {
                    // Check or Bet
                    if (Math.random() < 0.1) action = 'raise'; // Small bluff
                    else action = 'check';
                } else {
                    // Call or Fold or Raise
                    if (toCall > bot.chips) {
                        // All in call?
                        action = 'call'; // Always call all in for fun in V1
                    } else {
                        if (Math.random() > 0.2) action = 'call';
                        else action = 'fold';
                    }
                }

                // Execute
                if (action === 'raise') {
                    // Min raise or pot?
                    const raiseAmt = this.minBet + this.bigBlind;
                    // Actually raise needs to be valid.
                    // Let's just make it a fixed increment
                    const totalBet = raiseAmt;
                    if (totalBet > bot.chips) {
                        // Not enough to raise, just call
                        action = 'call';
                    } else {
                        bot.chips -= (totalBet - bot.currentBet);
                        bot.currentBet = totalBet;
                        this.pot += (totalBet - bot.currentBet); // Bug here? 
                        // Logic: chips reduced by delta. pot increased by delta.
                        // Correct logic:
                        // delta = total - current
                        // chips -= delta
                        // pot += delta
                        // current = total
                    }
                }

                if (action === 'call') {
                    const delta = Math.min(toCall, bot.chips);
                    bot.chips -= delta;
                    this.pot += delta;
                    bot.currentBet += delta;
                }

                if (action === 'fold') {
                    bot.folded = true;
                    // Remove from active?
                }

                // Update State
                if (action === 'raise') {
                    this.minBet = bot.currentBet;
                    this.lastAggressorIdx = this.players.indexOf(bot);
                    // Reset 'allMatched' cycle.
                    // Note: If someone raises, everyone else needs to act again.
                    // My completion logic checks (next == lastAggressor).
                    // If Bot 2 raises, lastAggressor becomes 2. 
                    // Loop continues 3, 0, 1... until 2 is reached again? 
                    // Yes. And logic checks if matched.
                }

                // Log
                this.log(`${bot.name} ${action}s`);

                // Update UI (simplified)
                this.updateUI();

                this.actionComplete(bot, action);
            }

            playerAction(action) {
                document.getElementById('user-controls').style.display = 'none';
                const p = this.players[0];
                let logAct = action;

                if (action === 'fold') {
                    p.folded = true;
                }
                else if (action === 'check') {
                    // pass
                }
                else if (action === 'call') {
                    const toCall = this.minBet - p.currentBet;
                    const delta = Math.min(toCall, p.chips);
                    p.chips -= delta;
                    this.pot += delta;
                    p.currentBet += delta;
                }
                else if (action === 'raise') {
                    // Simple Min Raise for now: 2x minBet or minBet + BB?
                    // Limit styles: Raise = Current Bet + Raise Amount.
                    // Let's do (Current MinBet + BigBlind) as new MinBet.
                    const newBet = this.minBet + this.bigBlind; // Minimum raise
                    const delta = newBet - p.currentBet;

                    if (p.chips < delta) {
                        // Not enough -> All in?
                        // Treat as call/all-in for now or forbid button
                        return; // Should act as call or error
                    }

                    p.chips -= delta;
                    this.pot += delta;
                    p.currentBet = newBet;
                    this.minBet = newBet;
                    this.lastAggressorIdx = 0;
                }

                this.log(`You ${logAct}`);
                this.updateUI();
                this.actionComplete(p, action);
            }

            async advanceStage() {
                // Reset bets for next street
                this.players.forEach(p => p.currentBet = 0);
                this.minBet = 0;
                this.bettingComplete = false;
                this.lastAggressorIdx = (this.dealerIdx + 1) % 4; // First to act starts
                this.currentTurnIdx = this.lastAggressorIdx;

                if (this.stage === 'preflop') {
                    this.stage = 'flop';
                    // Burn 1? Nah.
                    this.communityCards.push(this.deck.deal());
                    this.communityCards.push(this.deck.deal());
                    this.communityCards.push(this.deck.deal());
                }
                else if (this.stage === 'flop') {
                    this.stage = 'turn';
                    this.communityCards.push(this.deck.deal());
                }
                else if (this.stage === 'turn') {
                    this.stage = 'river';
                    this.communityCards.push(this.deck.deal());
                }
                else if (this.stage === 'river') {
                    this.stage = 'showdown';
                    this.handleShowdown();
                    return;
                }

                this.updateUI();
                this.log(`--- ${this.stage.toUpperCase()} ---`);

                // Start betting for new stage
                // Check if everyone all-in?
                const activeWithChips = this.players.filter(p => !p.folded && !p.isAllIn && p.chips > 0);
                if (activeWithChips.length < 2) {
                    // Auto-run to end?
                    // If 0 or 1 player has chips, no more betting possible.
                    // Just deal remaining cards and showdown.
                    // For now, let's just loop locally.
                    this.bettingComplete = true;
                    // Recursion danger?
                }

                // Allow UI to update
                await wait(600);
            }

            handleShowdown() {
                this.log("SHOWDOWN!");

                // Reveal all active hands
                // Evaluate
                let winner = null;
                let bestScore = -1;
                let winningHandName = "";

                const active = this.players.filter(p => !p.folded);

                active.forEach(p => {
                    const finalCards = [...p.hand, ...this.communityCards];
                    const evalRes = HandEvaluator.evaluate(finalCards);
                    p.eval = evalRes;
                    console.log(`${p.name} has ${evalRes.name} (${evalRes.score})`);

                    if (evalRes.score > bestScore) {
                        bestScore = evalRes.score;
                        winner = p;
                        winningHandName = evalRes.name;
                    }
                });

                // Award Pot
                winner.chips += this.pot;
                this.log(`${winner.name} wins $${this.pot} with ${winningHandName}!`);

                // Show cards in UI
                this.updateUI(true); // Showdown mode

                document.getElementById('game-message').innerText = `${winner.name} wins with ${winningHandName}!`;
                document.getElementById('game-message').style.display = 'block';
                document.getElementById('start-btn').innerText = "New Round";
                document.getElementById('start-btn').style.display = 'block';
            }

            log(msg) {
                console.log(msg); // TODO: Add on-screen log
                // document.getElementById('seat-0').querySelector('.seat-action').innerText = msg;
            }

            endRound() {
                // Determine winner if everyone folded
                const winner = this.players.find(p => !p.folded);
                winner.chips += this.pot;
                this.log(`${winner.name} wins pot (opponents folded)`);
                document.getElementById('game-message').innerText = `${winner.name} wins (Fold)`;
                document.getElementById('game-message').style.display = 'block';
                document.getElementById('start-btn').innerText = "New Round";
                document.getElementById('start-btn').style.display = 'block';
            }

            updateUI(showdown = false) {
                // Pot
                document.getElementById('pot-amount').innerText = this.pot;

                // Community Cards
                const commContainer = document.getElementById('community-cards');
                commContainer.innerHTML = '';
                this.communityCards.forEach(c => commContainer.appendChild(c.render()));

                // Players
                this.players.forEach((p, idx) => {
                    // Update chips
                    const seat = document.getElementById(`seat-${idx}`);
                    seat.querySelector('.seat-chips').innerText = `$${p.chips}`;
                    seat.querySelector('.seat-action').innerText = p.currentBet > 0 ? `Bet: ${p.currentBet}` : (p.folded ? 'Fold' : 'Check');
                    if (p.folded) seat.classList.add('folded');
                    else seat.classList.remove('folded');

                    // Cards
                    if (p.isHuman) {
                        const handContainer = document.getElementById('user-cards');
                        handContainer.innerHTML = '';
                        p.hand.forEach(c => handContainer.appendChild(c.render()));
                    } else {
                        // Bot Cards
                        const opCards = seat.querySelector('.op-cards');
                        opCards.innerHTML = '';
                        if (showdown && !p.folded) {
                            p.hand.forEach(c => opCards.appendChild(c.render()));
                        } else {
                            // Backs
                            opCards.innerHTML = `<div class="card back" style="width:30px; height:42px;"></div><div class="card back" style="width:30px; height:42px;"></div>`;
                        }
                    }

                    // Highlight Active
                    if (!showdown && idx === this.currentTurnIdx) {
                        seat.classList.add('active-turn');
                    } else {
                        seat.classList.remove('active-turn');
                    }
                });
            }
        }

        const game = new TexasHoldEm();

        // Initial Draw
        // game.startRound(); // Wait for user trigger

    </script>
</body>

</html>