<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Standard eBooks</title>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            image-rendering: -webkit-crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -o-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            background-repeat: repeat;
            background-position: top left;

            image-rendering: -webkit-optimize-contrast;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background-repeat: repeat;
            background-position: top left;

            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background-repeat: repeat;
            background-position: top left;

            font-family: "Georgia", serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            /* Background managed by settings */

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            height: 90vh;
            width: 95%;
            max-width: 900px;
            position: relative;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
            font-family: "Helvetica Neue", sans-serif;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        /* CLOSE BUTTON */
        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* CONTENT */
        .window-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background: white;
        }

        .book-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 20px;
            align-content: start;
        }

        .book-card {
            border: 1px solid #ccc;
            padding: 10px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .book-card:hover {
            border-color: black;
        }

        .cover-img {
            width: 100%;
            aspect-ratio: 2/3;
            object-fit: cover;
            background: #eee;
            border: 1px solid #000;
            margin-bottom: 10px;
        }

        .book-title {
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .book-author {
            font-size: 0.8rem;
            font-style: italic;
            color: #555;
            margin-bottom: 8px;
        }

        .download-btn {
            margin-top: auto;
            background: black;
            color: white;
            border: none;
            padding: 6px;
            font-weight: bold;
            cursor: pointer;
            font-family: sans-serif;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .download-btn:disabled {
            background: #ccc;
            cursor: default;
        }

        /* LOADING */
        #loading-indicator {
            text-align: center;
            padding: 40px;
            font-style: italic;
            color: #666;
            grid-column: 1 / -1;
        }

        #status-bar {
            border-top: 2px solid black;
            padding: 4px;
            font-size: 0.75rem;
            background: #eee;
            text-align: center;
            flex-shrink: 0;
            font-family: sans-serif;
        }

        /* TOAST */
        #toast {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: black;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: sans-serif;
            font-weight: bold;
            display: none;
            z-index: 100;
        }
    </style>
    <script src="theme.js"></script>
    <script src="js/i18n.js"></script>
</head>

<body>

    <div class="window">
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="location.href='index'">X</div>
            <span class="title-text" data-i18n="se.title">Standard eBooks</span>
        </div>

        <div class="window-content">
            <div class="book-grid" id="book-grid">
            </div>
        </div>

        <div id="status-bar" data-i18n="se.status.connecting">Connecting to Standard Ebooks...</div>
        <div id="toast" data-i18n="se.msg.started">Download Started...</div>
    </div>

    <script>
        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        // Configure for Safari/Mac compatibility (fixes CORS errors)

        if (db.settings) {

            try {

                db.settings({

                    experimentalForceLongPolling: true,

                    merge: true

                });

            } catch (e) { console.warn("Settings error:", e); }

        }


        // Note: Persistence disabled due to IndexedDB hangs on some browsers (Safari)

        // db.enablePersistence({ synchronizeTabs: true }) ...

        const auth = firebase.auth();

        // --- STATE ---
        let currentUser = null;

        // Feed URLs
        const RSS_FEED_URL = "https://standardebooks.org/feeds/rss/new-releases";

        // Use a robust CORS proxy chain to fetch XML/EPUB directly
        const PROXIES = [
            "https://corsproxy.io/?",
            "https://api.codetabs.com/v1/proxy?quest="
        ];

        // --- INIT ---
        window.onload = () => {
            if (window.rekindleApplyWallpaper) window.rekindleApplyWallpaper();
            loadFeed(); // Load new releases by default

            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    document.getElementById('status-bar').innerText = window.t('status.synced') + user.email;
                } else {
                    document.getElementById('status-bar').innerText = window.t('se.status.guest');
                }
            });
        };

        // Helper to HTML-escape text
        function escapeHTML(text) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(text));
            return div.innerHTML;
        }

        // Helper to sanitize background image URLs from localStorage
        function sanitizeBackgroundImage(imageString) {
            if (!imageString) return '';
            if (imageString.startsWith('url("data:image/png;base64,')) {
                return imageString;
            }
            if (imageString.startsWith('url("') && imageString.endsWith('")')) {
                const url = imageString.substring(5, imageString.length - 2);
                if ((url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) && !url.includes('javascript:')) {
                    return imageString;
                }
            }
            return '';
        }


        // --- FEED LOGIC (XML + PROXY) ---

        async function loadFeed() {
            renderLoading(window.t('se.msg.loading'));

            try {
                // Fetch via robust chain
                const text = await fetchWithProxy(RSS_FEED_URL);
                if (!text) throw new Error(window.t('se.error.proxies'));

                parseAndRenderXML(text);

            } catch (e) {
                console.error("Feed error", e);
                renderError(window.t('se.error.feed'));
            }
        }

        async function fetchWithProxy(url, isBinary = false) {
            for (let proxyBase of PROXIES) {
                try {
                    const res = await fetch(proxyBase + encodeURIComponent(url));
                    if (res.ok) {
                        return isBinary ? await res.blob() : await res.text();
                    }
                } catch (e) {
                    console.warn("Proxy failed:", proxyBase);
                }
            }
            return null;
        }

        function parseAndRenderXML(xmlText) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                // Check for parser errors
                const parserError = xmlDoc.getElementsByTagName("parsererror");
                if (parserError.length > 0) {
                    throw new Error(window.t('se.error.xml_parse'));
                }

                // Use getElementsByTagName for better compatibility with Kindle browser
                const items = Array.from(xmlDoc.getElementsByTagName("item")).slice(0, 15);

                if (items.length > 0) {
                    renderXmlBooks(items);
                } else {
                    throw new Error(window.t('se.error.no_items'));
                }
            } catch (e) {
                console.error("Parse error", e);
                renderError(window.t('se.error.parse') + e.message);
            }
        }

        // --- RENDERING ---
        function renderXmlBooks(items) {
            const grid = document.getElementById('book-grid');
            grid.innerHTML = '';

            items.forEach(item => {
                const titleEl = item.getElementsByTagName("title")[0];
                const rawTitle = titleEl ? titleEl.textContent : window.t('se.label.unknown_title');

                let title = rawTitle;
                let author = window.t('se.label.unknown_author');

                // Parse Standard Ebooks format: "Title, by Author"
                if (title.includes(", by ")) {
                    const separator = ", by ";
                    const lastIndex = title.lastIndexOf(separator);
                    if (lastIndex !== -1) {
                        author = title.substring(lastIndex + separator.length);
                        title = title.substring(0, lastIndex);
                    }
                }

                // Find EPUB link (enclosure)
                let dlUrl = null;
                const enclosures = item.getElementsByTagName("enclosure");
                for (let i = 0; i < enclosures.length; i++) {
                    const enc = enclosures[i];
                    if (enc.getAttribute("type") === "application/epub+zip") {
                        dlUrl = enc.getAttribute("url");
                        break;
                    }
                }

                // Fallback link
                if (!dlUrl) {
                    const linkEl = item.getElementsByTagName("link")[0];
                    if (linkEl) dlUrl = linkEl.textContent;
                }

                // Find Cover
                let coverUrl = "";
                // Try media:thumbnail or thumbnail
                const mediaThumb = item.getElementsByTagName("media:thumbnail")[0];
                const thumb = item.getElementsByTagName("thumbnail")[0];

                if (mediaThumb) coverUrl = mediaThumb.getAttribute("url");
                else if (thumb) coverUrl = thumb.getAttribute("url");

                // Fallback to parsing description for <img>
                if (!coverUrl) {
                    const descEl = item.getElementsByTagName("description")[0];
                    if (descEl) {
                        const desc = descEl.textContent || "";
                        const match = desc.match(/src=["'](.*?)["']/);
                        if (match) coverUrl = match[1];
                    }
                }

                // Fix Standard Ebooks Relative URLs if needed
                if (coverUrl && !coverUrl.startsWith('http')) {
                    coverUrl = "https://standardebooks.org" + coverUrl;
                }

                if (dlUrl) {
                    renderCard(grid, title, author, coverUrl, dlUrl);
                }
            });

            if (grid.children.length === 0) renderError(window.t('se.msg.none'));
        }

        // --- CARD COMPONENT ---
        function renderCard(container, title, author, coverUrl, dlUrl) {
            const div = document.createElement('div');
            div.className = 'book-card';

            // Clean title/author for onclick string
            const safeTitle = escapeQuotes(title);
            const safeAuthor = escapeQuotes(author);

            div.innerHTML = `
                <img src="${coverUrl || ''}" class="cover-img" onerror="this.style.backgroundColor='#ccc'">
                <div class="book-title">${title}</div>
                <div class="book-author">${author}</div>
                <button class="download-btn" onclick='downloadBook("${dlUrl}", "${safeTitle}", "${safeAuthor}", this)'>${window.t('se.btn.download')}</button>
            `;
            container.appendChild(div);
        }

        function escapeQuotes(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        }

        function renderLoading(msg) {
            document.getElementById('book-grid').innerHTML = `<div id="loading-indicator">${msg}</div>`;
        }

        function renderError(msg) {
            document.getElementById('book-grid').innerHTML = `<div id="loading-indicator" style="color:red;">${msg}</div>`;
        }

        // --- DOWNLOAD & CLEAN LOGIC ---
        async function downloadBook(url, title, author, btnElement) {
            btnElement.disabled = true;
            btnElement.innerText = window.t('se.btn.saving');
            showToast(`${window.t('common.loading')} ${title}...`);

            try {
                // 1. Fetch File Blob using robust proxy chain
                const blob = await fetchWithProxy(url, true);

                if (!blob || blob.size < 1000) throw new Error(window.t('se.error.invalid_file'));

                // 2. CLEANUP STEP: Remove blank pages
                showToast(window.t('se.msg.clean'));
                const cleanedBlob = await cleanEpub(blob);

                // 3. Convert to ArrayBuffer
                const buffer = await blobToArrayBuffer(cleanedBlob);

                // 4. Generate Key
                const key = `book_${Date.now()}`;

                // 5. Save to LocalForage (Shared storage with Reader app)
                await localforage.setItem(key, buffer);

                // 6. Update Index
                let index = await localforage.getItem('library_index') || [];
                const exists = index.find(b => b.title === title && b.author === author);

                if (!exists) {
                    index.push({
                        title: title,
                        author: author,
                        url: url,
                        key: key,
                        date: Date.now()
                    });
                    await localforage.setItem('library_index', index);
                }

                // 7. Cloud Sync (if logged in)
                if (currentUser) {
                    const snap = await db.collection('users').doc(currentUser.uid).collection('library')
                        .where('url', '==', url).get();

                    if (snap.empty) {
                        await db.collection('users').doc(currentUser.uid).collection('library').add({
                            title: title,
                            author: author,
                            url: url,
                            cfi: null,
                            added: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                btnElement.innerText = window.t('se.btn.saved');
                showToast(window.t('se.msg.saved'));

            } catch (e) {
                console.error(e);
                btnElement.innerText = window.t('se.btn.error');
                btnElement.disabled = false;
                showToast(window.t('se.error.generic') + e.message);
            }
        }

        // --- EPUB CLEANER (FIXED) ---
        async function cleanEpub(blob) {
            try {
                const zip = await JSZip.loadAsync(blob);

                // 1. Find OPF file path
                const containerXml = await zip.file("META-INF/container.xml").async("string");
                const rootfileMatch = containerXml.match(/full-path="([^"]+)"/);
                if (!rootfileMatch) throw new Error(window.t('se.error.invalid_container'));

                const opfPath = rootfileMatch[1];
                let opfContent = await zip.file(opfPath).async("string");

                // 2. Parse OPF
                const parser = new DOMParser();
                const opfDoc = parser.parseFromString(opfContent, "application/xml");
                const manifest = opfDoc.getElementsByTagName("manifest")[0];
                const spine = opfDoc.getElementsByTagName("spine")[0];
                // Handle optional namespace if present
                const ns = opfDoc.documentElement.namespaceURI;

                const getItemHref = (id) => {
                    let item = null;
                    // Try with querySelector if ID is simple
                    try {
                        if (ns) item = manifest.querySelector(`[id="${id}"]`);
                    } catch (e) { }

                    // Fallback loop if querySelector fails or ID has special chars
                    if (!item) {
                        for (let i = 0; i < manifest.children.length; i++) {
                            if (manifest.children[i].getAttribute("id") === id) {
                                item = manifest.children[i];
                                break;
                            }
                        }
                    }
                    return item ? item.getAttribute("href") : null;
                };

                // 3. Iterate Spine Items
                const itemrefs = Array.from(spine.getElementsByTagName("itemref"));
                let removedCount = 0;

                const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);

                for (let itemref of itemrefs) {
                    const id = itemref.getAttribute("idref");
                    const href = getItemHref(id);

                    if (href && (href.endsWith('.html') || href.endsWith('.xhtml'))) {
                        const fullPath = opfDir + href;
                        const file = zip.file(fullPath);

                        if (file) {
                            const content = await file.async("string");

                            // 4. FIX: Use textContent for XML/XHTML documents
                            const doc = parser.parseFromString(content, "application/xml");

                            // Robust text extraction
                            const text = doc.documentElement.textContent.trim();

                            const hasImg = doc.getElementsByTagName("img").length > 0;
                            const hasSvg = doc.getElementsByTagName("svg").length > 0;
                            const hasImage = doc.getElementsByTagName("image").length > 0;

                            // If text is very short (< 50 chars) AND no images/graphics
                            if (text.length < 50 && !hasImg && !hasSvg && !hasImage) {
                                spine.removeChild(itemref);
                                removedCount++;
                            }
                        }
                    }
                }

                if (removedCount > 0) {
                    const serializer = new XMLSerializer();
                    const newOpfContent = serializer.serializeToString(opfDoc);
                    zip.file(opfPath, newOpfContent);
                    return await zip.generateAsync({ type: "blob", mimeType: "application/epub+zip" });
                }

                return blob;

            } catch (e) {
                console.error("Clean failed, returning original", e);
                return blob;
            }
        }

        function blobToArrayBuffer(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(blob);
            });
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 3000);
        }




    </script>
    <script src="https://cdn.counter.dev/script.js" data-id="4e551911-0e5d-4c48-91a6-b828c3301675"
        data-utcoffset="11"></script>
</body>

</html>