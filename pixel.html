<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            image-rendering: pixelated;
            font-family: "Geneva", "Verdana", sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
            touch-action: none;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 800px;
            position: relative;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        /* CLOSE BUTTON (HOME) */
        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* SCREENS */
        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .screen.active {
            display: flex;
        }

        /* GALLERY SCREEN */
        #screen-gallery {
            padding: 0;
            background: #eee;
        }

        .gallery-header {
            padding: 10px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            flex-shrink: 0;
        }

        .gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 20px;
            overflow-y: auto;
            align-content: start;
        }

        .gallery-item {
            background: white;
            border: 2px solid black;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            box-shadow: 4px 4px 0 #ccc;
            aspect-ratio: 1 / 1.2;
            justify-content: space-between;
            position: relative;
        }

        .gallery-item:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #ccc;
            background: black;
            color: white;
        }

        .gallery-preview {
            width: 100%;
            aspect-ratio: 1/1;
            border: 1px solid #ddd;
            image-rendering: pixelated;
            background: white;
            pointer-events: none;
        }

        .gallery-item.new-btn {
            justify-content: center;
            border-style: dashed;
            background: #fafafa;
        }

        .gallery-item.new-btn span {
            font-size: 3rem;
            font-weight: bold;
            color: #ccc;
        }

        .item-info {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            font-weight: bold;
        }

        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: white;
            border: 2px solid black;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
        }

        .delete-btn:hover {
            background: black;
            color: white;
        }

        /* GAME AREA */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            flex-grow: 1;
            background: white;
        }

        /* ... existing styles ... */

        #canvas-container {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
            /* Needed for absolute positioning of layers */
            flex-grow: 1;
            /* Allow it to take space */
            min-height: 200px;
        }

        /* Canvas Layers */
        #pixel-canvas,
        #grid-canvas {
            position: absolute;
            /* Layer them on top of each other */
            image-rendering: pixelated;
            /* Crucial for crisp pixels */
            /* Centered manually via JS or flexbox if not absolute. 
               Since absolute, we need to center them. 
               Let's set left/top 50% transform -50%? 
               Or just set left/top to (containerW - canvasW)/2 in JS. 
               Actually, let's keep it simple: 
               We will make sure the container is exactly the size of canvas in JS. */
            top: 0;
            left: 0;
        }

        #pixel-canvas {
            z-index: 1;
            background: white;
            border: 2px solid black;
            /* Border on the bottom one */
        }

        #grid-canvas {
            z-index: 2;
            /* Grid sits on top */
            pointer-events: none;
            /* Let clicks pass through to pixel canvas */
            /* No border here to align perfectly */
        }

        /* CONTROLS */
        .controls {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
            /* adjusted margin */
            padding-bottom: 10px;
        }

        /* ... existing styles ... */

        button {
            background: white;
            border: 2px solid black;
            padding: 8px 15px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        button:active {
            background: black;
            color: white;
            transform: translate(2px, 2px);
            box-shadow: none;
        }

        button.active {
            background: black;
            color: white;
        }

        /* MODALS */
        .modal-overlay {
            display: none;
            position: fixed;
            /* Use fixed to cover viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(229, 229, 229, 0.9);
            /* Match body bg with transparency */
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-box {
            background: white;
            border: 2px solid black;
            box-shadow: 8px 8px 0 black;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            text-align: center;
        }

        .modal-box h3 {
            margin-top: 0;
            border-bottom: 2px solid black;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .sys-btn {
            background: white;
            border: 2px solid black;
            padding: 8px 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 black;
            font-family: inherit;
            margin-top: 10px;
            text-transform: uppercase;
        }

        .sys-btn:active {
            box-shadow: none;
            transform: translate(3px, 3px);
        }

        /* SLIDER STYLES */
        input[type=range].gradient-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 25px;
            background: linear-gradient(to right, black, white);
            border: 2px solid black;
            outline: none;
            cursor: pointer;
            margin: 0;
        }

        input[type=range].gradient-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 35px;
            background: white;
            border: 2px solid black;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
        }

        input[type=range].gradient-slider::-moz-range-thumb {
            width: 15px;
            height: 35px;
            background: white;
            border: 2px solid black;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
        }
    </style>
    <script src="theme.js"></script>
</head>

<body>

    <div id="new-drawing-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>New Drawing</h3>
            <p style="margin-bottom:20px;">Select grid size:</p>
            <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
                <button class="sys-btn" onclick="createNew(16)">16x16</button>
                <button class="sys-btn" onclick="createNew(32)">32x32</button>
                <button class="sys-btn" onclick="createNew(64)">64x64</button>
            </div>
            <button class="sys-btn" style="margin-top:20px; background:#ddd;"
                onclick="closeModal('new-drawing-modal')">Cancel</button>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Delete Drawing?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to delete this drawing? This cannot be undone.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="confirm-delete-btn">Delete</button>
                <button class="sys-btn" onclick="closeModal('delete-modal')">Cancel</button>
            </div>
        </div>
    </div>

    <div id="grid-size-modal" class="modal-overlay">
        <!-- Kept for compatibility but strictly we don't need resize anymore if we have new drawing flow, 
             but user might want to resize current. Handling resize on existing drawing is tricky with data loss.
             Let's keep it but it clears the drawing. -->
        <div class="modal-box">
            <h3 id="grid-size-modal-title">Change Grid Size?</h3>
            <p style="margin-bottom:20px;" id="grid-size-modal-text">Switch to a different grid size?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="grid-size-confirm-btn">Yes</button>
                <button class="sys-btn" onclick="closeModal('grid-size-modal')">No</button>
            </div>
        </div>
    </div>

    <div id="clear-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Clear Canvas?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to clear the canvas?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="confirmClear()">Yes</button>
                <button class="sys-btn" onclick="closeModal('clear-modal')">No</button>
            </div>
        </div>
    </div>

    <!-- POST CONFIRM MODAL -->
    <div id="post-confirm-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Post to KindleChat?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to post this drawing to KindleChat?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="confirmPost()">Yes</button>
                <button class="sys-btn" onclick="closeModal('post-confirm-modal')">No</button>
            </div>
        </div>
    </div>

    <!-- SUCCESS MODAL -->
    <div id="success-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Posted!</h3>
            <p style="margin-bottom:20px;">Your art has been posted to KindleChat.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="closeModal('success-modal')">OK</button>
            </div>
        </div>
    </div>

    <div class="window">
        <!-- SHARED TITLE BAR -->
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="handleCloseButton()">X</div>
            <span class="title-text">Pixel</span>
            <!-- Contextual Back Button -->
            <div id="back-to-chat-btn" class="close-box"
                style="left:auto; right:10px; width:auto; padding:0 8px; font-weight:normal; display:none;"
                onclick="window.location.href='kindlechat'">
                Back to Chat
            </div>
        </div>

        <!-- GALLERY SCREEN -->
        <div id="screen-gallery" class="screen active">
            <div class="gallery-header">
                <span style="font-weight:bold; margin-left:10px;">My Drawings</span>
                <!-- Stats or simple info -->
            </div>
            <div id="gallery-grid" class="gallery-grid">
                <!-- Injected via JS -->
                <div class="gallery-item new-btn" onclick="openModal('new-drawing-modal')">
                    <span>+</span>
                    <div class="item-info">New Drawing</div>
                </div>
            </div>
        </div>

        <!-- EDITOR SCREEN -->
        <div id="screen-editor" class="screen">
            <!-- New Header with Title Input -->
            <div
                style="background:white; border-bottom:2px solid black; padding:10px; display:flex; justify-content:center;">
                <input type="text" id="drawing-title" placeholder="Untitled" maxlength="20"
                    style="font-family:inherit; font-weight:bold; font-size:1.2rem; text-align:center; border:none; outline:none; background:transparent; width:100%;">
            </div>

            <div class="game-content">
                <div id="canvas-container">
                    <canvas id="pixel-canvas"></canvas>
                    <canvas id="grid-canvas"></canvas>
                </div>

                <!-- Full Width Slider Container -->
                <div id="slider-container" style="margin-bottom: 10px;">
                    <input type="range" id="shade-slider" class="gradient-slider" min="0" max="100" value="0"
                        title="Shade Selector" oninput="updateShade(this.value)">
                </div>

                <div class="controls">
                    <button class="active" onclick="showGallery()">Back</button>
                    <div style="width:10px;"></div>

                    <!-- Tools -->
                    <button id="tool-pen" class="active" onclick="setTool('pen')">Pen</button>
                    <button id="tool-eraser" onclick="setTool('eraser')">Eraser</button>

                    <div style="width:10px;"></div>

                    <button onclick="clearGrid()">Clear</button>
                    <div style="width:10px;"></div>
                    <button class="sys-btn" style="padding: 8px 10px; font-size: 0.8rem; margin-top:0;"
                        onclick="openModal('post-confirm-modal')">Post to KindleChat</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('pixel-canvas');
        const gridCanvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const gridCtx = gridCanvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // --- STATE ---
        let currentDrawingId = null; // null if new unsaved, or ID string
        let gridSize = 32;
        let cellSize;
        let grid;
        let currentTool = 'pen';
        let currentShade = 1; // 0 to 1
        let isDrawing = false;

        let lastDrawnRow = -1;
        let lastDrawnCol = -1;

        // Auto-save timer
        let autoSaveTimer = null;

        // Manifest: Array of { id, created, modified, size, thumbnail? }
        let manifest = [];

        // Firebase variables
        let db, auth, currentUser = null;

        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77"
        };


        // --- INIT ---
        window.onload = () => {
            loadWallpaper();

            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();

            auth.onAuthStateChanged(user => {
                currentUser = user;
                initApp(); // Load manifest and render gallery
            });

            // Input handlers
            // Note: We attach these to canvas but ensure they work
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', moveDrawing);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointerleave', stopDrawing);

            // Prevent context menu
            canvas.oncontextmenu = (e) => e.preventDefault();

            // Check for source param
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('source') === 'kindlechat') {
                const backBtn = document.getElementById('back-to-chat-btn');
                if (backBtn) backBtn.style.display = 'flex';
            }
        };

        async function postToPixelChat() {
            if (!currentUser) return alert("You must be logged in to post.");

            // Get data URL from the pixel canvas only (no grid)
            const dataUrl = canvas.toDataURL('image/png');

            try {
                // Ensure PixelChat room exists or at least we can write to it
                // We just write to the collection 'rooms/pixelchat/messages'
                // The KindleChat client handles the room list inclusion regardless of document existence, 
                // but creating the room doc is good practice if missing.

                const roomRef = db.collection('rooms').doc('general');

                // Optional: Ensure validation exists
                // await roomRef.set({ name: 'PixelChat', type: 'group' }, { merge: true });

                await roomRef.collection('messages').add({
                    user: currentUser.email.split('@')[0],
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    text: document.getElementById('drawing-title').value || "Pixel Art",
                    pixel_art: dataUrl,
                    is_pixel_art: true
                });

                openModal('success-modal');
            } catch (e) {
                console.error("Error posting:", e);
                alert("Failed to post. Check console.");
            }
        }

        function confirmPost() {
            closeModal('post-confirm-modal');
            postToPixelChat();
        }

        window.onresize = () => {
            if (currentDrawingId) setupCanvas(false); // Resize canvas if in editor
        };

        async function initApp() {
            await loadManifest();
            migrateLegacyData(); // One-off check
            renderGallery();
        }

        // --- MANIFEST & DATA ---
        async function loadManifest() {
            const key = 'pixel_manifest';

            // Try Cloud first if logged in
            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('settings').doc('pixel_manifest').get();
                    if (doc.exists) {
                        manifest = doc.data().items || [];
                        localStorage.setItem(key, JSON.stringify(manifest));
                        return;
                    }
                } catch (e) { console.error("Cloud manifest load failed", e); }
            }

            // Fallback to local
            const local = localStorage.getItem(key);
            if (local) {
                try { manifest = JSON.parse(local); } catch (e) { manifest = []; }
            } else {
                manifest = [];
            }
        }

        async function saveManifest() {
            const key = 'pixel_manifest';
            localStorage.setItem(key, JSON.stringify(manifest)); // Always save local

            if (currentUser) {
                try {
                    await db.collection('users').doc(currentUser.uid).collection('settings').doc('pixel_manifest').set({ items: manifest });
                } catch (e) { console.error("Cloud manifest save failed", e); }
            }
        }

        // Migrate old singular keys (pixel_art_16, pixel_art_32, etc) to new system
        function migrateLegacyData() {
            let changed = false;
            [16, 32, 64].forEach(size => {
                const legacyKey = `pixel_art_${size}`;
                const data = localStorage.getItem(legacyKey);
                if (data) {
                    // Check if is empty (all zeros) - crudely
                    // If complex check needed, parse it.
                    // Let's just import it.

                    const id = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                    const newEntry = {
                        id: id,
                        title: `Untitled (${size}x${size})`,
                        created: Date.now(),
                        modified: Date.now(),
                        size: size,
                        thumbnail: null // Will be generated on first open/save
                    };

                    // Save content to new key
                    localStorage.setItem(`pixel_drawing_${id}`, data);
                    // Add to manifest
                    manifest.push(newEntry);
                    // Remove old key
                    localStorage.removeItem(legacyKey);
                    changed = true;
                }
            });
            if (changed) {
                saveManifest();
                renderGallery();
            }
        }

        async function loadDrawingData(id) {
            const key = `pixel_drawing_${id}`;
            let data = null;

            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).get();
                    if (doc.exists) data = doc.data().grid;
                } catch (e) { console.error(e); }
            }

            if (!data) data = localStorage.getItem(key);

            return data ? JSON.parse(data) : null;
        }

        async function saveDrawingData(id, gridData) {
            const key = `pixel_drawing_${id}`;
            const json = JSON.stringify(gridData);

            localStorage.setItem(key, json);

            if (currentUser) {
                // background save
                db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).set({ grid: json })
                    .catch(console.error);
            }
        }

        // --- GALLERY UI ---
        function renderGallery() {
            const gridEl = document.getElementById('gallery-grid');
            // Keep the "New" button (first child)
            const newBtn = gridEl.firstElementChild;
            gridEl.innerHTML = '';
            gridEl.appendChild(newBtn);

            // Sort by modified desc
            const sorted = [...manifest].sort((a, b) => b.modified - a.modified);

            sorted.forEach(item => {
                const el = document.createElement('div');
                el.className = 'gallery-item';
                el.onclick = (e) => {
                    if (!e.target.closest('.delete-btn')) openDrawing(item.id);
                };

                // Content
                let thumbHtml = '';
                if (item.thumbnail) {
                    thumbHtml = `<img src="${item.thumbnail}" class="gallery-preview">`;
                } else {
                    thumbHtml = `<div class="gallery-preview" style="background:#f0f0f0; display:flex; align-items:center; justify-content:center; color:#ccc;">?</div>`;
                }

                const title = item.title || "Untitled";
                const dateStr = new Date(item.modified).toLocaleDateString();

                el.innerHTML = `
                    <div class="delete-btn" onclick="deleteDrawing('${item.id}')">X</div>
                    ${thumbHtml}
                    <div class="item-info">
                        <div style="font-size:0.9rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:100px;">${title}</div>
                        <span style="font-weight:normal; color:#666; font-size:0.7rem;">${item.size}x${item.size}</span>
                    </div>
                `;
                gridEl.appendChild(el);
            });
        }

        let drawingToDeleteId = null;

        function deleteDrawing(id) {
            drawingToDeleteId = id;
            document.getElementById('confirm-delete-btn').onclick = () => performDelete(drawingToDeleteId);
            openModal('delete-modal');
        }

        function performDelete(id) {
            manifest = manifest.filter(m => m.id !== id);
            saveManifest();
            localStorage.removeItem(`pixel_drawing_${id}`);

            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).delete();
            }

            closeModal('delete-modal');
            renderGallery();
        }

        // --- EDITOR ACTIONS ---
        function createNew(size) {
            gridSize = size;

            currentDrawingId = null; // Mark as new/unsaved
            grid = createGrid(size); // Empty grid

            closeModal('new-drawing-modal');
            showEditor();
            setupCanvas(false);
            redrawAllPixels(); // Force clear to white (fixes Kindle black screen)

            // Set title input
            const titleInput = document.getElementById('drawing-title');
            titleInput.value = "Untitled";
            titleInput.blur();
        }

        async function openDrawing(id) {
            const item = manifest.find(m => m.id === id);
            if (!item) return;

            currentDrawingId = id;
            gridSize = item.size;

            // Set Title
            document.getElementById('drawing-title').value = item.title || "Untitled";

            // Load data
            const data = await loadDrawingData(id);
            if (data) {
                grid = data;
            } else {
                grid = createGrid(gridSize); // Should not happen, but fallback
            }

            showEditor();
            setupCanvas(false);
            // We need to redraw pixels from loaded grid
            redrawAllPixels();
        }

        // Title Input Listener
        document.getElementById('drawing-title').addEventListener('input', (e) => {
            // For title edit, we want to save immediately (debounced)
            // This acts as a 'modification' that triggers save
            triggerAutoSave();
        });

        function showGallery() {
            // If unsaved (null ID) and clean? 
            // We just discard if nothing was drawn.
            // But if user modified, performSave would have created ID.

            document.getElementById('screen-editor').classList.remove('active');
            document.getElementById('screen-gallery').classList.add('active');
            renderGallery(); // Update thumbnails and titles
        }

        function showEditor() {
            document.getElementById('screen-gallery').classList.remove('active');
            document.getElementById('screen-editor').classList.add('active');
            // document.querySelector('.title-text').innerText = "Pixel Editor";
        }

        function handleCloseButton() {
            if (document.getElementById('screen-editor').classList.contains('active')) {
                showGallery();
            } else {
                window.location.href = 'index';
            }
        }

        // --- DRAWING LOGIC (Modified for AutoSave) ---
        function createGrid(size) {
            return new Array(size).fill(null).map(() => new Array(size).fill(0));
        }

        function setupCanvas(reset = true) {
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight || (window.innerHeight - 150);

            // Ensure container has size.
            // If resize event, clientWidth is valid.

            const maxDimension = Math.min(containerWidth, window.innerHeight - 150);
            const validSize = Math.max(200, maxDimension);

            const canvasSize = Math.floor(validSize / gridSize) * gridSize;

            canvas.width = canvasSize;
            canvas.height = canvasSize;
            gridCanvas.width = canvasSize;
            gridCanvas.height = canvasSize;

            // Center it? CSS handles centering if flex and size is set?
            // Actually, if we set absolute, we need to manually center or set container size to match exactly.
            // Best is to set container size to match canvas size.
            container.style.width = canvasSize + 'px';
            container.style.height = canvasSize + 'px';
            container.style.flexGrow = '0'; // Stop it from expanding weirdly

            // Resize Slider Container to match
            const sliderCont = document.getElementById('slider-container');
            if (sliderCont) {
                sliderCont.style.width = canvasSize + 'px';
            }

            cellSize = canvas.width / gridSize;

            drawGridLines();
            if (reset) {
                grid = createGrid(gridSize);
                redrawAllPixels();
            }
        }

        function drawGridLines() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            if (cellSize <= 4) return;

            gridCtx.strokeStyle = '#bbb'; // Darker grid lines for better visibility
            gridCtx.lineWidth = 1;
            gridCtx.beginPath();

            for (let i = 0; i <= gridSize; i++) {
                const pos = Math.floor(i * cellSize) + 0.5;
                gridCtx.moveTo(pos, 0);
                gridCtx.lineTo(pos, gridCanvas.height);
                gridCtx.moveTo(0, pos);
                gridCtx.lineTo(canvas.width, pos);
            }
            gridCtx.stroke();
        }

        function redrawAllPixels() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    drawPixel(r, c, grid[r][c]);
                }
            }
        }

        function drawPixel(row, col, value) {
            // Value is 0..1 (1=Black, 0=White)
            if (value === 0) {
                ctx.fillStyle = 'white';
            } else if (value === 1) {
                ctx.fillStyle = 'black';
            } else {
                // Greyscale mapping
                const shade = Math.round((1 - value) * 255);
                ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            }
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function drawLine(r0, c0, r1, c1, value) {
            let x0 = c0, y0 = r0;
            let x1 = c1, y1 = r1;

            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                if (y0 >= 0 && y0 < gridSize && x0 >= 0 && x0 < gridSize) {
                    if (grid[y0][x0] !== value) {
                        grid[y0][x0] = value;
                        drawPixel(y0, x0, value);
                    }
                }
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function handleDraw(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX || event.touches[0].clientX) - rect.left;
            const y = (event.clientY || event.touches[0].clientY) - rect.top;

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (col >= 0 && col < gridSize && row >= 0 && row < gridSize) {
                // Round to 2 decimal places for storage efficiency
                const penVal = Math.round(currentShade * 100) / 100;
                const newValue = (currentTool === 'eraser') ? 0 : penVal;

                if (lastDrawnRow !== -1 && lastDrawnCol !== -1) {
                    drawLine(lastDrawnRow, lastDrawnCol, row, col, newValue);
                } else {
                    if (grid[row][col] !== newValue) {
                        grid[row][col] = newValue;
                        drawPixel(row, col, newValue);
                    }
                }
                lastDrawnRow = row;
                lastDrawnCol = col;
            }
        }

        function startDrawing(e) {
            isDrawing = true;
            lastDrawnRow = -1;
            lastDrawnCol = -1;
            handleDraw(e);
        }

        function moveDrawing(e) {
            if (isDrawing) handleDraw(e);
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                lastDrawnRow = -1;
                lastDrawnCol = -1;
                triggerAutoSave();
            }
        }

        // --- AUTO SAVE ---
        function triggerAutoSave() {
            // Cancel pending
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(performSave, 500);
        }

        function performSave() {
            // New Drawing Logic
            if (!currentDrawingId) {
                // Generate ID
                const id = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                currentDrawingId = id;

                const titleVal = document.getElementById('drawing-title').value.trim() || "Untitled";

                // Add to manifest
                manifest.unshift({
                    id: id,
                    title: titleVal,
                    created: Date.now(),
                    modified: Date.now(),
                    size: gridSize,
                    thumbnail: null // will be set below
                });
            }

            // Save Grid Data
            saveDrawingData(currentDrawingId, grid);

            // Update Manifest (Timestamp + Thumbnail + Title)
            const item = manifest.find(m => m.id === currentDrawingId);
            if (item) {
                item.title = document.getElementById('drawing-title').value.trim() || "Untitled";
                item.modified = Date.now();
                item.thumbnail = canvas.toDataURL('image/png'); // Generate thumbnail
                saveManifest();
            }
        }

        // --- UI HELPERS ---
        function clearGrid() {
            openModal('clear-modal');
        }

        function confirmClear() {
            grid = createGrid(gridSize);
            redrawAllPixels();
            triggerAutoSave(); // Save cleared state
            closeModal('clear-modal');
        }

        // --- MODAL FUNCTIONS (kept existing) ---
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('tool-pen').classList.toggle('active', tool === 'pen');
            document.getElementById('tool-eraser').classList.toggle('active', tool === 'eraser');
        }

        function updateShade(val) {
            // val is 0-100 from slider
            // 0 (Left) = Black (1.0)
            // 100 (Right) = White (0.0)
            currentShade = 1.0 - (val / 100);

            // Auto-switch to pen if user adjusts slider
            if (currentTool !== 'pen') setTool('pen');
        }

        // Helper to sanitize background image URLs from localStorage (from reference)
        function sanitizeBackgroundImage(imageString) {
            if (!imageString) return '';
            if (imageString.startsWith('url("data:image/png;base64,')) {
                return imageString;
            }
            if (imageString.startsWith('url("') && imageString.endsWith('")')) {
                const url = imageString.substring(5, imageString.length - 2);
                if ((url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) && !url.includes('javascript:')) {
                    return imageString;
                }
            }
            return '';
        }



        loadWallpaper();

        function loadWallpaper() {
            const wallpaperImg = localStorage.getItem('rekindle_bg_image');
            const wallpaperSize = localStorage.getItem('rekindle_bg_size');
            if (wallpaperImg) {
                document.body.style.backgroundImage = wallpaperImg;
            }
            if (wallpaperSize) {
                document.body.style.backgroundSize = wallpaperSize;
            }
        }
    </script>
</body>

```