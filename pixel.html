<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <style>
        /* SYSTEM 7 AESTHETICS */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border: 2px solid #000000;
            --shadow: 4px 4px 0px #000000;
            --stripe-pattern: repeating-linear-gradient(0deg, transparent, transparent 2px, #000 3px, #000 4px);
        }

        body {
            image-rendering: pixelated;
            font-family: "Geneva", "Verdana", sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
            background-color: #e5e5e5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            box-sizing: border-box;
            touch-action: none;
        }

        /* WINDOW FRAME */
        .window {
            background: white;
            border: 2px solid black;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            width: 90%;
            max-width: 800px;
            max-height: 95vh;
            position: relative;
        }

        /* TITLE BAR */
        .title-bar {
            height: 35px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            padding: 0 10px;
            position: relative;
            flex-shrink: 0;
        }

        .title-stripes {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background-image: var(--stripe-pattern);
            z-index: 0;
        }

        .title-text {
            background: white;
            padding: 0 15px;
            font-weight: bold;
            z-index: 1;
            font-size: 1.1rem;
        }

        /* CLOSE BUTTON (HOME) */
        .close-box {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            border: 2px solid black;
            background: white;
            z-index: 2;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.9rem;
            line-height: 1;
            box-shadow: 2px 2px 0 black;
        }

        .close-box:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* SCREENS */
        .screen {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .screen.active {
            display: flex;
        }

        /* GALLERY SCREEN */
        #screen-gallery {
            padding: 0;
            background: #eee;
        }

        .gallery-header {
            padding: 10px;
            border-bottom: 2px solid black;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            flex-shrink: 0;
        }

        .gallery-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 20px;
            overflow-y: auto;
            align-content: start;
        }

        .gallery-item {
            background: white;
            border: 2px solid black;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            box-shadow: 4px 4px 0 #ccc;
            aspect-ratio: 1 / 1.2;
            justify-content: space-between;
            position: relative;
        }

        .gallery-item:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #ccc;
            background: black;
            color: white;
        }

        .gallery-preview {
            width: 100%;
            aspect-ratio: 1/1;
            border: 1px solid #ddd;
            image-rendering: pixelated;
            background: white;
            pointer-events: none;
            flex-shrink: 0;
            /* Ensure squareness */
            object-fit: contain;
        }

        .gallery-item.new-btn {
            justify-content: center;
            border-style: dashed;
            background: #fafafa;
        }

        .gallery-item.new-btn span {
            font-size: 3rem;
            font-weight: bold;
            color: #ccc;
        }

        .item-info {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            font-weight: bold;
        }

        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: white;
            border: 2px solid black;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
        }

        .delete-btn:hover {
            background: black;
            color: white;
        }

        /* GAME AREA */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 10px;
            flex-grow: 1;
            background: white;
        }

        /* ... existing styles ... */

        #canvas-container {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            position: relative;
            /* Needed for absolute positioning of layers */
            flex-grow: 1;
            /* Allow it to take space */
            min-height: 200px;
        }

        /* Canvas Layers */
        #pixel-canvas,
        #grid-canvas {
            position: absolute;
            /* Layer them on top of each other */
            image-rendering: pixelated;
            /* Crucial for crisp pixels */
            /* Centered manually via JS or flexbox if not absolute. 
               Since absolute, we need to center them. 
               Let's set left/top 50% transform -50%? 
               Or just set left/top to (containerW - canvasW)/2 in JS. 
               Actually, let's keep it simple: 
               We will make sure the container is exactly the size of canvas in JS. */
            top: 0;
            left: 0;
        }

        #pixel-canvas {
            z-index: 1;
            background: white;
            border: 2px solid black;
            /* Border on the bottom one */
        }

        #grid-canvas {
            z-index: 2;
            /* Grid sits on top */
            pointer-events: none;
            /* Let clicks pass through to pixel canvas */
            /* No border here to align perfectly */
        }

        /* REFINED CONTROLS LAYOUT */
        .controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 10px;
            width: 100%;
            background: #d6d6d6;
            /* System 7 Grey */
            border-top: 1px solid black;
            box-sizing: border-box;
            flex-wrap: nowrap;
        }

        .control-group {
            display: flex;
            border: 1px solid black;
            background: black;
            /* Dividers */
            gap: 1px;
            padding: 0;
        }

        .control-group .sys-btn {
            border-radius: 0;
            margin: 0;
            border: none;
            width: auto;
            min-width: 44px;
            padding: 0 12px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            box-shadow: none;
            cursor: pointer;
            gap: 8px;
        }

        .btn-label {
            font-size: 0.9rem;
            font-weight: bold;
        }

        .control-group .sys-btn:active,
        .control-group .sys-btn.active {
            background: black;
            color: white;
            transform: none;
            box-shadow: none;
        }

        .control-group .sys-btn svg {
            width: 22px;
            height: 22px;
        }

        .sys-btn.caution:hover {
            background: red;
            color: white;
        }

        /* MODALS */
        .modal-overlay {
            display: none;
            position: fixed;
            /* Use fixed to cover viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(229, 229, 229, 0.9);
            /* Match body bg with transparency */
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-box {
            background: white;
            border: 2px solid black;
            box-shadow: 8px 8px 0 black;
            padding: 20px;
            width: 90%;
            max-width: 320px;
            text-align: center;
        }

        .modal-box h3 {
            margin-top: 0;
            border-bottom: 2px solid black;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .sys-btn {
            background: white;
            border: 2px solid black;
            padding: 8px 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 0 black;
            font-family: inherit;
            margin-top: 10px;
            text-transform: uppercase;
        }

        .sys-btn:active {
            box-shadow: none;
            transform: translate(3px, 3px);
        }

        /* SLIDER STYLES */
        input[type=range].gradient-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 25px;
            background: linear-gradient(to right, black, white);
            border: 2px solid black;
            outline: none;
            cursor: pointer;
            margin: 0;
        }

        input[type=range].gradient-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 35px;
            background: white;
            border: 2px solid black;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
        }

        input[type=range].gradient-slider::-moz-range-thumb {
            width: 15px;
            height: 35px;
            background: white;
            border: 2px solid black;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
        }

        /* STANDARD MODAL SYSTEM */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            font-family: "Geneva", "Verdana", sans-serif;
        }

        .modal-box {
            background: white;
            border: 2px solid black;
            padding: 20px;
            box-shadow: 6px 6px 0 black;
            max-width: 300px;
            width: 80%;
            text-align: center;
        }

        .modal-text {
            margin-bottom: 20px;
            font-weight: bold;
            line-height: 1.4;
            color: black;
        }

        .modal-btns {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            background: white;
            border: 2px solid black;
            padding: 6px 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 0 black;
            font-family: inherit;
        }

        .modal-btn:active {
            background: black;
            color: white;
            transform: translate(1px, 1px);
            box-shadow: none;
        }

        /* MENU BAR (OS 9 Style) */
        .menu-bar {
            display: flex;
            width: 100%;
            border-bottom: 2px solid black;
            background: white;
            padding: 2px 5px;
            gap: 15px;
            box-sizing: border-box;
            flex-shrink: 0;
            align-items: center;
        }

        .menu-btn {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 2px 6px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            text-transform: capitalize;
            font-weight: normal;
        }

        .menu-btn:hover,
        .menu-btn:active {
            background: black;
            color: white;
            transform: none;
            box-shadow: none;
        }
    </style>
    <script src="theme.js"></script>
</head>

<body>

    <!-- STANDARD MODAL POPUP -->
    <div id="modal-overlay">
        <div class="modal-box">
            <div id="modal-message" class="modal-text"></div>
            <div id="modal-btns" class="modal-btns"></div>
        </div>
    </div>

    <div id="new-drawing-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>New Drawing</h3>
            <p style="margin-bottom:20px;">Select grid size:</p>
            <div style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
                <button class="sys-btn" onclick="createNew(16)">16x16</button>
                <button class="sys-btn" onclick="createNew(32)">32x32</button>
                <button class="sys-btn" onclick="createNew(64)">64x64</button>
            </div>
            <button class="sys-btn" style="margin-top:20px; background:#ddd;"
                onclick="closeModal('new-drawing-modal')">Cancel</button>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Delete Drawing?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to delete this drawing? This cannot be undone.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="confirm-delete-btn">Delete</button>
                <button class="sys-btn" onclick="closeModal('delete-modal')">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rename-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Rename Drawing</h3>
            <input type="text" id="rename-input" maxlength="20"
                style="width:80%; padding:5px; margin-bottom:20px; font-family:inherit; font-weight:bold; text-align:center; border:2px solid black;">
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="confirm-rename-btn" style="text-transform: none;">Rename</button>
                <button class="sys-btn" onclick="closeModal('rename-modal')">Cancel</button>
            </div>
        </div>
    </div>

    <div id="grid-size-modal" class="modal-overlay">
        <!-- Kept for compatibility but strictly we don't need resize anymore if we have new drawing flow, 
             but user might want to resize current. Handling resize on existing drawing is tricky with data loss.
             Let's keep it but it clears the drawing. -->
        <div class="modal-box">
            <h3 id="grid-size-modal-title">Change Grid Size?</h3>
            <p style="margin-bottom:20px;" id="grid-size-modal-text">Switch to a different grid size?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" id="grid-size-confirm-btn">Yes</button>
                <button class="sys-btn" onclick="closeModal('grid-size-modal')">No</button>
            </div>
        </div>
    </div>

    <div id="clear-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Clear Canvas?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to clear the canvas?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="confirmClear()">Yes</button>
                <button class="sys-btn" onclick="closeModal('clear-modal')">No</button>
            </div>
        </div>
    </div>

    <!-- POST CONFIRM MODAL -->
    <div id="post-confirm-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Post to KindleChat?</h3>
            <p style="margin-bottom:20px;">Are you sure you want to post this drawing to KindleChat?</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="confirmPost()">Yes</button>
                <button class="sys-btn" onclick="closeModal('post-confirm-modal')">No</button>
            </div>
        </div>
    </div>

    <!-- SUCCESS MODAL -->
    <div id="success-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Posted!</h3>
            <p style="margin-bottom:20px;">Your art has been posted to KindleChat.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="closeModal('success-modal')">OK</button>
            </div>
        </div>
    </div>

    <!-- WALLPAPER SUCCESS MODAL -->
    <div id="wallpaper-modal" class="modal-overlay">
        <div class="modal-box">
            <h3>Wallpaper Set!</h3>
            <p style="margin-bottom:20px;">Your new wallpaper has been applied.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="sys-btn" onclick="closeModal('wallpaper-modal')">OK</button>
            </div>
        </div>
    </div>

    <div class="window">
        <!-- SHARED TITLE BAR -->
        <div class="title-bar">
            <div class="title-stripes"></div>
            <div class="close-box" onclick="handleCloseButton()">X</div>
            <!-- Editor Back Button -->
            <div id="editor-back-btn" class="close-box" style="left:38px; width:auto; padding:0 5px; display:none;"
                onclick="showGallery()">
                Back
            </div>
            <span class="title-text">Pixel</span>
            <!-- Contextual Back Button -->
            <div id="back-to-chat-btn" class="close-box"
                style="left:auto; right:10px; width:auto; padding:0 8px; font-weight:normal; display:none;"
                onclick="window.location.href='kindlechat'">
                Back to Chat
            </div>
        </div>

        <!-- GALLERY SCREEN -->
        <div id="screen-gallery" class="screen active">
            <div class="gallery-header">
                <span style="font-weight:bold; margin-left:10px;">My Drawings</span>
                <!-- Stats or simple info -->
            </div>
            <div id="gallery-grid" class="gallery-grid">
                <!-- Injected via JS -->
                <div class="gallery-item new-btn" onclick="openModal('new-drawing-modal')">
                    <span>+</span>
                    <div class="item-info">New Drawing</div>
                </div>
            </div>
        </div>

        <!-- EDITOR SCREEN -->
        <div id="screen-editor" class="screen">
            <!-- Menu Bar -->
            <div class="menu-bar">
                <button class="menu-btn" onclick="downloadImage()">Download</button>
                <button class="menu-btn" onclick="setWallpaper()">Set Background</button>
                <button class="menu-btn" onclick="openModal('post-confirm-modal')">Post to KindleChat</button>
            </div>

            <div class="game-content">

                <div id="canvas-container">
                    <canvas id="pixel-canvas"></canvas>
                    <canvas id="grid-canvas"></canvas>
                </div>

                <!-- Full Width Slider Container -->
                <div id="slider-container" style="margin-bottom: 10px;">
                    <input type="range" id="shade-slider" class="gradient-slider" min="0" max="100" value="0"
                        title="Shade Selector" oninput="updateShade(this.value)">
                </div>

                <div class="controls-container">
                    <div class="control-group">
                        <button id="tool-pen" class="sys-btn active" onclick="setTool('pen')" title="Pen">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M18 2l4 4-10 10H8v-4L18 2z"></path>
                            </svg>
                            <span class="btn-label">Pen</span>
                        </button>
                        <button id="tool-eraser" class="sys-btn" onclick="setTool('eraser')" title="Eraser">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"></path>
                            </svg>
                            <span class="btn-label">Eraser</span>
                        </button>
                        <button class="sys-btn" onclick="clearGrid()" title="Clear Canvas">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M18 6L6 18M6 6l12 12"></path>
                            </svg>
                            <span class="btn-label">Clear</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('pixel-canvas');
        const gridCanvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const gridCtx = gridCanvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // --- STATE ---
        let currentDrawingId = null; // null if new unsaved, or ID string
        let gridSize = 32;
        let cellSize;
        let grid;
        let currentTool = 'pen';
        let currentShade = 1; // 0 to 1
        let isDrawing = false;

        let lastDrawnRow = -1;
        let lastDrawnCol = -1;

        // Auto-save timer
        let autoSaveTimer = null;

        // Manifest: Array of { id, created, modified, size, thumbnail? }
        let manifest = [];

        // Firebase variables
        let db, auth, currentUser = null;

        const firebaseConfig = {
            apiKey: "AIzaSyDY7x7vVmlYUyVZNLuCCmIQYa6PWFVfZqQ",
            authDomain: "rekindle-dd1fa.firebaseapp.com",
            projectId: "rekindle-dd1fa",
            storageBucket: "rekindle-dd1fa.firebasestorage.app",
            messagingSenderId: "748026882518",
            appId: "1:748026882518:web:6877dd4329318070c11c77",
            databaseURL: "https://rekindle-dd1fa-default-rtdb.firebaseio.com/"
        };


        // --- INIT ---
        window.onload = () => {
            // --- CONFIGURATION ---
            function showModal(msg, isConfirm = false, callback = null) {
                const overlay = document.getElementById('modal-overlay');
                const messageEl = document.getElementById('modal-message');
                const btnsEl = document.getElementById('modal-btns');
                messageEl.textContent = msg;
                if (isConfirm) {
                    btnsEl.innerHTML = '<button class="modal-btn" id="modal-cancel">Cancel</button><button class="modal-btn" id="modal-ok">OK</button>';
                    document.getElementById('modal-cancel').onclick = () => { overlay.style.display = 'none'; if (callback) callback(false); };
                    document.getElementById('modal-ok').onclick = () => { overlay.style.display = 'none'; if (callback) callback(true); };
                } else {
                    btnsEl.innerHTML = '<button class="modal-btn" onclick="hideModal()">OK</button>';
                }
                overlay.style.display = 'flex';
            }
            function hideModal() { document.getElementById('modal-overlay').style.display = 'none'; }

            if (window.rekindleApplyWallpaper) window.rekindleApplyWallpaper();

            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            rtdb = firebase.database();

            // Configure for Safari/Mac compatibility (fixes CORS errors)


            if (db.settings) {


                try {


                    db.settings({


                        experimentalForceLongPolling: true,


                        merge: true


                    });


                } catch (e) { console.warn("Settings error:", e); }


            }



            // Note: Persistence disabled due to IndexedDB hangs on some browsers (Safari)


            // db.enablePersistence({ synchronizeTabs: true }) ...

            auth.onAuthStateChanged(user => {
                currentUser = user;
                initApp(); // Load manifest and render gallery
            });

            // Input handlers
            canvas.addEventListener('pointerdown', startDrawing);
            canvas.addEventListener('pointermove', moveDrawing);
            canvas.addEventListener('pointerup', stopDrawing);
            canvas.addEventListener('pointerleave', stopDrawing);

            // Prevent context menu
            canvas.oncontextmenu = (e) => e.preventDefault();

            // Check for source param
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('source') === 'kindlechat') {
                const backBtn = document.getElementById('back-to-chat-btn');
                if (backBtn) backBtn.style.display = 'flex';
            }
        };

        function canUserSend(chatHistory, currentUserId) {
            // 1. CONFIGURATION
            const MAX_SCORE = 3.0;      // If user's score > 3, block them.
            const DECAY_RATE = 0.05;    // How much 'less' an older message counts.
            const SCAN_DEPTH = 50;      // Look at up to 50 messages.

            let score = 0;

            // 2. SAFETY CHECK (If chat is empty, let them send)
            if (!chatHistory || chatHistory.length === 0) return true;

            // 3. CALCULATE SCORE
            // Assumes chatHistory[0] is the MOST RECENT message
            const limit = Math.min(chatHistory.length, SCAN_DEPTH);

            for (let i = 0; i < limit; i++) {
                // Only count messages from this specific user
                if (chatHistory[i].userId === currentUserId) {

                    // Calculate weight: 1.0, 0.95, 0.90, etc.
                    let weight = 1.0 - (i * DECAY_RATE);

                    // If weight drops to 0 or below, we stop counting
                    if (weight <= 0) break;

                    score += weight;
                }
            }

            console.log(`User Score: ${score.toFixed(2)} / ${MAX_SCORE}`);

            // 4. VERDICT
            return score < MAX_SCORE;
        }

        async function postToPixelChat() {
            if (!currentUser) return showModal("You must be logged in to post.");

            // Get data URL from the pixel canvas only (no grid)
            const dataUrl = canvas.toDataURL('image/png');
            const currentUsername = currentUser.email.split('@')[0];

            try {
                // Use RTDB for 'general' chat messages (where artwork goes)
                const messagesRef = rtdb.ref('kindlechat/messages');

                // MODERATION CHECK
                const snapshot = await messagesRef.orderByChild('timestamp').limitToLast(50).once('value');
                const history = [];
                snapshot.forEach(child => {
                    const val = child.val();
                    if (val.user) {
                        history.push({ userId: val.user });
                    }
                });
                history.reverse(); // Newest first

                if (!canUserSend(history, currentUsername)) {
                    closeModal('post-confirm-modal');
                    showModal('To ensure a good experience for everyone, please slow down. You\'ve been posting a lot recently.', false);
                    return;
                }

                await messagesRef.push({
                    user: currentUsername,
                    text: 'Shared a pixel art!',
                    pixel_art: dataUrl,
                    is_pixel_art: true,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                closeModal('post-confirm-modal');
                showModal("Posted to KindleChat!", false, null);

                // Show success modal wrapper
                const successModal = document.getElementById('success-modal');
                if (successModal) successModal.style.display = 'flex';

            } catch (e) {
                console.error("Error posting:", e);
                showModal("Error posting: " + e.message);
            }
        }

        function confirmPost() {
            closeModal('post-confirm-modal');
            postToPixelChat();
        }

        window.onresize = () => {
            if (currentDrawingId) setupCanvas(false); // Resize canvas if in editor
        };

        async function initApp() {
            await loadManifest();
            migrateLegacyData(); // One-off check
            renderGallery();
        }

        // --- MANIFEST & DATA ---
        async function loadManifest() {
            const key = 'pixel_manifest';

            // Try Cloud first if logged in
            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('settings').doc('pixel_manifest').get();
                    if (doc.exists) {
                        manifest = doc.data().items || [];
                        localStorage.setItem(key, JSON.stringify(manifest));
                        return;
                    }
                } catch (e) { console.error("Cloud manifest load failed", e); }
            }

            // Fallback to local
            const local = localStorage.getItem(key);
            if (local) {
                try { manifest = JSON.parse(local); } catch (e) { manifest = []; }
            } else {
                manifest = [];
            }
        }

        async function saveManifest() {
            const key = 'pixel_manifest';
            localStorage.setItem(key, JSON.stringify(manifest)); // Always save local

            if (currentUser) {
                try {
                    await db.collection('users').doc(currentUser.uid).collection('settings').doc('pixel_manifest').set({ items: manifest });
                } catch (e) { console.error("Cloud manifest save failed", e); }
            }
        }

        // Migrate old singular keys (pixel_art_16, pixel_art_32, etc) to new system
        function migrateLegacyData() {
            let changed = false;
            [16, 32, 64].forEach(size => {
                const legacyKey = `pixel_art_${size}`;
                const data = localStorage.getItem(legacyKey);
                if (data) {
                    // Check if is empty (all zeros) - crudely
                    // If complex check needed, parse it.
                    // Let's just import it.

                    const id = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                    const newEntry = {
                        id: id,
                        title: `Untitled (${size}x${size})`,
                        created: Date.now(),
                        modified: Date.now(),
                        size: size,
                        thumbnail: null // Will be generated on first open/save
                    };

                    // Save content to new key
                    localStorage.setItem(`pixel_drawing_${id}`, data);
                    // Add to manifest
                    manifest.push(newEntry);
                    // Remove old key
                    localStorage.removeItem(legacyKey);
                    changed = true;
                }
            });
            if (changed) {
                saveManifest();
                renderGallery();
            }
        }

        async function loadDrawingData(id) {
            const key = `pixel_drawing_${id}`;
            let data = null;

            if (currentUser) {
                try {
                    const doc = await db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).get();
                    if (doc.exists) data = doc.data().grid;
                } catch (e) { console.error(e); }
            }

            if (!data) data = localStorage.getItem(key);

            return data ? JSON.parse(data) : null;
        }

        async function saveDrawingData(id, gridData) {
            const key = `pixel_drawing_${id}`;
            const json = JSON.stringify(gridData);

            localStorage.setItem(key, json);

            if (currentUser) {
                // background save
                db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).set({ grid: json })
                    .catch(console.error);
            }
        }

        // --- GALLERY UI ---
        function renderGallery() {
            const gridEl = document.getElementById('gallery-grid');
            // Keep the "New" button (first child)
            const newBtn = gridEl.firstElementChild;
            gridEl.innerHTML = '';
            gridEl.appendChild(newBtn);

            // Sort by modified desc
            const sorted = [...manifest].sort((a, b) => b.modified - a.modified);

            sorted.forEach(item => {
                const el = document.createElement('div');
                el.className = 'gallery-item';
                el.onclick = (e) => {
                    if (!e.target.closest('.action-btn')) openDrawing(item.id);
                };

                // Content
                let thumbHtml = '';
                if (item.thumbnail) {
                    thumbHtml = `<img src="${item.thumbnail}" class="gallery-preview">`;
                } else {
                    thumbHtml = `<div class="gallery-preview" style="background:#f0f0f0; display:flex; align-items:center; justify-content:center; color:#ccc;">?</div>`;
                }

                const title = item.title || "Untitled";
                const dateStr = new Date(item.modified).toLocaleDateString();

                el.innerHTML = `
                    <div class="delete-btn action-btn" onclick="deleteDrawing('${item.id}')">X</div>
                    ${thumbHtml}
                    <div class="item-info">
                        <div onclick="event.stopPropagation(); promptRename('${item.id}')" style="font-size:0.9rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:100px; cursor:pointer; text-decoration:underline;">${title}</div>
                        <span style="font-weight:normal; color:#666; font-size:0.7rem;">${item.size}x${item.size}</span>
                    </div>
                `;
                gridEl.appendChild(el);
            });
        }

        let renameId = null;
        function promptRename(id) {
            const item = manifest.find(m => m.id === id);
            if (!item) return;
            renameId = id;
            document.getElementById('rename-input').value = item.title || "Untitled";
            document.getElementById('confirm-rename-btn').onclick = performRename;
            openModal('rename-modal');
        }

        function performRename() {
            const newTitle = document.getElementById('rename-input').value.trim() || "Untitled";
            const item = manifest.find(m => m.id === renameId);
            if (item) {
                item.title = newTitle;
                item.modified = Date.now();
                saveManifest();
                renderGallery();
            }
            closeModal('rename-modal');
        }

        let drawingToDeleteId = null;

        function deleteDrawing(id) {
            drawingToDeleteId = id;
            document.getElementById('confirm-delete-btn').onclick = () => performDelete(drawingToDeleteId);
            openModal('delete-modal');
        }

        function performDelete(id) {
            manifest = manifest.filter(m => m.id !== id);
            saveManifest();
            localStorage.removeItem(`pixel_drawing_${id}`);

            if (currentUser) {
                db.collection('users').doc(currentUser.uid).collection('pixel_drawings').doc(id).delete();
            }

            closeModal('delete-modal');
            renderGallery();
        }

        // --- EDITOR ACTIONS ---
        function createNew(size) {
            gridSize = size;

            currentDrawingId = null; // Mark as new/unsaved
            grid = createGrid(size); // Empty grid

            closeModal('new-drawing-modal');
            showEditor();
            setupCanvas(false);
            redrawAllPixels(); // Force clear to white (fixes Kindle black screen)

            // Set title input
            const titleInput = document.getElementById('drawing-title');
            if (titleInput) {
                titleInput.value = "Untitled";
                titleInput.blur();
            }
        }

        async function openDrawing(id) {
            const item = manifest.find(m => m.id === id);
            if (!item) return;

            currentDrawingId = id;
            gridSize = item.size;

            // Set Title - No longer needed in header
            // document.getElementById('drawing-title').value = item.title || "Untitled";

            // Load data
            const data = await loadDrawingData(id);
            if (data) {
                grid = data;
            } else {
                grid = createGrid(gridSize); // Should not happen, but fallback
            }

            showEditor();
            setupCanvas(false);
            redrawAllPixels();
        }

        // Title Input Listener - Removed
        // document.getElementById('drawing-title').addEventListener('input', (e) => {
        //     // For title edit, we want to save immediately (debounced)
        //     // This acts as a 'modification' that triggers save
        //     triggerAutoSave();
        // });

        function showGallery() {
            // If unsaved (null ID) and clean? 
            // We just discard if nothing was drawn.
            // But if user modified, performSave would have created ID.

            document.getElementById('screen-editor').classList.remove('active');
            document.getElementById('screen-gallery').classList.add('active');

            const backBtn = document.getElementById('editor-back-btn');
            if (backBtn) backBtn.style.display = 'none';

            renderGallery(); // Update thumbnails and titles
        }

        function showEditor() {
            document.getElementById('screen-gallery').classList.remove('active');
            document.getElementById('screen-editor').classList.add('active');
            // document.querySelector('.title-text').innerText = "Pixel Editor";

            const backBtn = document.getElementById('editor-back-btn');
            if (backBtn) backBtn.style.display = 'flex';
        }

        function handleCloseButton() {
            window.location.href = 'index';
        }

        // --- DRAWING LOGIC (Modified for AutoSave) ---
        function createGrid(size) {
            return new Array(size).fill(null).map(() => new Array(size).fill(0));
        }

        function setupCanvas(reset = true) {
            // Guard: Only run if container is visible
            if (container.offsetParent === null) return;

            // Get scale factor early
            const scaleStr = localStorage.getItem('rekindle_scale') || '1.0';
            const scale = parseFloat(scaleStr);

            // Reset container size AND zoom to allow it to expand/shrink freely in LOGICAL pixels before measuring
            container.style.width = '';
            container.style.height = '';
            container.style.zoom = '';

            const containerWidth = container.clientWidth;

            // Calculate available height dynamically to maximize space
            // Window constraints: max-height: 90vh, margin 20px (body padding)
            // We need to fit within the smaller of 90vh or (100vh - 40px)
            // IMPORTANT: window.innerHeight is PHYSICAL (unscaled). We must converting to LOGICAL pixels if scaled.
            const logicalWindowH = window.innerHeight / scale;
            const maxWindowHeight = Math.min(logicalWindowH * 0.9, logicalWindowH - (40 / scale));

            // Measure UI elements
            // Measure UI elements
            const titleBarH = document.querySelector('.title-bar').offsetHeight;
            const menuBar = document.querySelector('.menu-bar');
            const menuBarH = (menuBar && menuBar.offsetParent !== null) ? menuBar.offsetHeight : 0;

            const sliderEl = document.getElementById('slider-container');
            const sliderH = sliderEl && sliderEl.offsetParent !== null ? (sliderEl.offsetHeight + 10) : 0;

            const controlsList = document.querySelectorAll('.controls');
            let controlsH = 0;
            controlsList.forEach(el => {
                if (el.offsetParent !== null) {
                    controlsH += el.offsetHeight + 10;
                }
            });

            // Total non-canvas height with safety buffer
            const uiHeight = titleBarH + menuBarH + sliderH + controlsH + 30;

            const availableHeight = maxWindowHeight - uiHeight;
            const containerHeight = availableHeight;



            // Ensure container has size.
            // If resize event, clientWidth is valid.

            // Multiply by scale so that when inverse zoom (1/scale) is applied, it fits the available area.
            const maxDimension = Math.min(containerWidth, availableHeight) * scale;
            const validSize = Math.max(200, maxDimension);

            const canvasSize = Math.floor(validSize / gridSize) * gridSize;

            // Apply Inverse Scaling to Canvas Container
            if (scale !== 1.0 && scale > 0) {
                // Use zoom if supported (WebKit), mimicking theme.js logic could be better but simple logic first
                container.style.zoom = (1.0 / scale);
            } else {
                container.style.zoom = '';
            }

            canvas.width = canvasSize;
            canvas.height = canvasSize;
            gridCanvas.width = canvasSize;
            gridCanvas.height = canvasSize;

            // Center it? CSS handles centering if flex and size is set?
            // Actually, if we set absolute, we need to manually center or set container size to match exactly.
            // Best is to set container size to match canvas size.
            container.style.width = canvasSize + 'px';
            container.style.height = canvasSize + 'px';
            container.style.flexGrow = '0'; // Stop it from expanding weirdly

            // Resize Slider Container to match
            const sliderCont = document.getElementById('slider-container');
            if (sliderCont) {
                sliderCont.style.width = canvasSize + 'px';
            }

            cellSize = canvas.width / gridSize;

            drawGridLines();
            if (reset) {
                grid = createGrid(gridSize);
                redrawAllPixels();
            }
        }

        function drawGridLines() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            if (cellSize <= 4) return;

            // Adjust thickness based on scaling
            const scaleStr = localStorage.getItem('rekindle_scale') || '1.0';
            const scale = parseFloat(scaleStr);

            gridCtx.strokeStyle = '#bbb'; // Darker grid lines for better visibility
            gridCtx.lineWidth = (scale < 1.0) ? 2 : 1;
            gridCtx.beginPath();

            for (let i = 0; i <= gridSize; i++) {
                const pos = Math.floor(i * cellSize) + (gridCtx.lineWidth % 2 === 0 ? 0 : 0.5);
                gridCtx.moveTo(pos, 0);
                gridCtx.lineTo(pos, gridCanvas.height);
                gridCtx.moveTo(0, pos);
                gridCtx.lineTo(canvas.width, pos);
            }
            gridCtx.stroke();
        }

        function redrawAllPixels() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    drawPixel(r, c, grid[r][c]);
                }
            }
        }

        function drawPixel(row, col, value) {
            // Value is 0..1 (1=Black, 0=White)
            if (value === 0) {
                ctx.fillStyle = 'white';
            } else if (value === 1) {
                ctx.fillStyle = 'black';
            } else {
                // Greyscale mapping
                const shade = Math.round((1 - value) * 255);
                ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            }
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function drawLine(r0, c0, r1, c1, value) {
            let x0 = c0, y0 = r0;
            let x1 = c1, y1 = r1;

            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                if (y0 >= 0 && y0 < gridSize && x0 >= 0 && x0 < gridSize) {
                    if (grid[y0][x0] !== value) {
                        grid[y0][x0] = value;
                        drawPixel(y0, x0, value);
                    }
                }
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function handleDraw(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX || event.touches[0].clientX) - rect.left;
            const y = (event.clientY || event.touches[0].clientY) - rect.top;

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (col >= 0 && col < gridSize && row >= 0 && row < gridSize) {
                // Round to 2 decimal places for storage efficiency
                const penVal = Math.round(currentShade * 100) / 100;
                const newValue = (currentTool === 'eraser') ? 0 : penVal;

                if (lastDrawnRow !== -1 && lastDrawnCol !== -1) {
                    drawLine(lastDrawnRow, lastDrawnCol, row, col, newValue);
                } else {
                    if (grid[row][col] !== newValue) {
                        grid[row][col] = newValue;
                        drawPixel(row, col, newValue);
                    }
                }
                lastDrawnRow = row;
                lastDrawnCol = col;
            }
        }

        function startDrawing(e) {
            isDrawing = true;
            lastDrawnRow = -1;
            lastDrawnCol = -1;
            handleDraw(e);
        }

        function moveDrawing(e) {
            if (isDrawing) handleDraw(e);
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                lastDrawnRow = -1;
                lastDrawnCol = -1;
                triggerAutoSave();
            }
        }

        // --- AUTO SAVE ---
        function triggerAutoSave() {
            // Cancel pending
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(performSave, 500);
        }

        function performSave() {
            // New Drawing Logic
            if (!currentDrawingId) {
                // Generate ID
                const id = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                currentDrawingId = id;

                const titleVal = "Untitled"; // Default title for new

                // Add to manifest
                manifest.unshift({
                    id: id,
                    title: titleVal,
                    created: Date.now(),
                    modified: Date.now(),
                    size: gridSize,
                    thumbnail: null // will be set below
                });
            }

            // Save Grid Data
            saveDrawingData(currentDrawingId, grid);

            // Update Manifest (Timestamp + Thumbnail + Title)
            const item = manifest.find(m => m.id === currentDrawingId);
            if (item) {
                // item.title = document.getElementById('drawing-title').value.trim() || "Untitled";
                item.modified = Date.now();
                item.thumbnail = canvas.toDataURL('image/png'); // Generate thumbnail
                saveManifest();
            }
        }

        // --- UI HELPERS ---
        function clearGrid() {
            openModal('clear-modal');
        }

        function confirmClear() {
            grid = createGrid(gridSize);
            redrawAllPixels();
            triggerAutoSave(); // Save cleared state
            closeModal('clear-modal');
        }

        // --- MODAL FUNCTIONS (kept existing) ---
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.controls-container .sys-btn').forEach(btn => btn.classList.remove('active'));
            if (tool === 'pen') document.getElementById('tool-pen').classList.add('active');
            if (tool === 'eraser') document.getElementById('tool-eraser').classList.add('active');
        }

        function updateShade(val) {
            // val is 0-100 from slider
            // 0 (Left) = Black (1.0)
            // 100 (Right) = White (0.0)
            currentShade = 1.0 - (val / 100);

            // Auto-switch to pen if user adjusts slider
            if (currentTool !== 'pen') setTool('pen');
        }







        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pixel-art.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function setWallpaper() {
            // Create a small tile from the grid data (not the scaled canvas)
            // This mimics how settings.html creates the 8x8 grid as a 32x32 tile

            // We'll create a tile where each pixel is 1px, then scale via background-size
            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = gridSize;
            tileCanvas.height = gridSize;
            const tileCtx = tileCanvas.getContext('2d');

            // Fill white background
            tileCtx.fillStyle = '#ffffff';
            tileCtx.fillRect(0, 0, gridSize, gridSize);

            // Draw each pixel from the grid
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const value = grid[row][col];
                    if (value !== 0) {
                        // Greyscale mapping (1 = black, 0 = white)
                        if (value === 1) {
                            tileCtx.fillStyle = '#000000';
                        } else {
                            const shade = Math.round((1 - value) * 255);
                            tileCtx.fillStyle = `rgb(${shade},${shade},${shade})`;
                        }
                        tileCtx.fillRect(col, row, 1, 1);
                    }
                }
            }

            // Get Data URL
            const dataUrl = tileCanvas.toDataURL('image/png');
            const cssUrl = `url("${dataUrl}")`;

            // Display size: same as the tile size for 1:1 pixel mapping
            // This creates a nice tiling pattern
            const sizeVal = `${gridSize}px ${gridSize}px`;

            // Save to LocalStorage
            localStorage.setItem('rekindle_bg_image', cssUrl);
            localStorage.setItem('rekindle_bg_size', sizeVal);
            localStorage.setItem('rekindle_wallpaper_id', 'custom');

            // Apply immediately to current view
            if (window.rekindleApplyWallpaper) window.rekindleApplyWallpaper();

            // Notify
            openModal('wallpaper-modal');
        }
    </script>
    <script src="https://cdn.counter.dev/script.js" data-id="4e551911-0e5d-4c48-91a6-b828c3301675"
        data-utcoffset="11"></script>
</body>